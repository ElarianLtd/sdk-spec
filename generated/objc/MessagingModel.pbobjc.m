// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messaging_model.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "MessagingModel.pbobjc.h"
#import "CommonModel.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(CustomerNumber);
GPBObjCClassDeclaration(DequeueCallAction);
GPBObjCClassDeclaration(DialCallAction);
GPBObjCClassDeclaration(EmailMessageBody);
GPBObjCClassDeclaration(EnqueueCallAction);
GPBObjCClassDeclaration(GPBDuration);
GPBObjCClassDeclaration(GPBInt32Value);
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(GetDigitsCallAction);
GPBObjCClassDeclaration(GetRecordingCallAction);
GPBObjCClassDeclaration(LocationMessageBody);
GPBObjCClassDeclaration(MediaMessageBody);
GPBObjCClassDeclaration(MessagingChannelNumber);
GPBObjCClassDeclaration(OutboundMessageBody);
GPBObjCClassDeclaration(OutboundMessageReplyPrompt);
GPBObjCClassDeclaration(PlayCallAction);
GPBObjCClassDeclaration(PromptMessageMenuItemBody);
GPBObjCClassDeclaration(RecordSessionCallAction);
GPBObjCClassDeclaration(RedirectCallAction);
GPBObjCClassDeclaration(RejectCallAction);
GPBObjCClassDeclaration(SayCallAction);
GPBObjCClassDeclaration(TemplateMessageBody);
GPBObjCClassDeclaration(UssdInputMessageBody);
GPBObjCClassDeclaration(UssdMenuMessageBody);
GPBObjCClassDeclaration(VoiceCallAction);
GPBObjCClassDeclaration(VoiceCallDialInput);
GPBObjCClassDeclaration(VoiceCallDialplanMessageBody);
GPBObjCClassDeclaration(VoiceCallInputMessageBody);
GPBObjCClassDeclaration(VoiceCallQueueInput);

#pragma mark - MessagingModelRoot

@implementation MessagingModelRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MessagingModelRoot_FileDescriptor

static GPBFileDescriptor *MessagingModelRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.elarian.hera.proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum MessagingChannel

GPBEnumDescriptor *MessagingChannel_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MessagingChannelUnspecified\000MessagingCha"
        "nnelSms\000MessagingChannelVoice\000MessagingC"
        "hannelUssd\000MessagingChannelFbMessenger\000M"
        "essagingChannelTelegram\000MessagingChannel"
        "Whatsapp\000MessagingChannelEmail\000";
    static const int32_t values[] = {
        MessagingChannel_MessagingChannelUnspecified,
        MessagingChannel_MessagingChannelSms,
        MessagingChannel_MessagingChannelVoice,
        MessagingChannel_MessagingChannelUssd,
        MessagingChannel_MessagingChannelFbMessenger,
        MessagingChannel_MessagingChannelTelegram,
        MessagingChannel_MessagingChannelWhatsapp,
        MessagingChannel_MessagingChannelEmail,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessagingChannel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessagingChannel_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessagingChannel_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessagingChannel_MessagingChannelUnspecified:
    case MessagingChannel_MessagingChannelSms:
    case MessagingChannel_MessagingChannelVoice:
    case MessagingChannel_MessagingChannelUssd:
    case MessagingChannel_MessagingChannelFbMessenger:
    case MessagingChannel_MessagingChannelTelegram:
    case MessagingChannel_MessagingChannelWhatsapp:
    case MessagingChannel_MessagingChannelEmail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessagingConsentUpdate

GPBEnumDescriptor *MessagingConsentUpdate_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MessagingConsentUpdateUnspecified\000Messag"
        "ingConsentUpdateAllow\000MessagingConsentUp"
        "dateBlock\000";
    static const int32_t values[] = {
        MessagingConsentUpdate_MessagingConsentUpdateUnspecified,
        MessagingConsentUpdate_MessagingConsentUpdateAllow,
        MessagingConsentUpdate_MessagingConsentUpdateBlock,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessagingConsentUpdate)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessagingConsentUpdate_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessagingConsentUpdate_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessagingConsentUpdate_MessagingConsentUpdateUnspecified:
    case MessagingConsentUpdate_MessagingConsentUpdateAllow:
    case MessagingConsentUpdate_MessagingConsentUpdateBlock:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessagingConsentUpdateStatus

GPBEnumDescriptor *MessagingConsentUpdateStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MessagingConsentUpdateStatusUnspecified\000"
        "MessagingConsentUpdateStatusQueued\000Messa"
        "gingConsentUpdateStatusCompleted\000Messagi"
        "ngConsentUpdateStatusInvalidChannelNumbe"
        "r\000MessagingConsentUpdateStatusDecommissi"
        "onedCustomerId\000MessagingConsentUpdateSta"
        "tusApplicationError\000";
    static const int32_t values[] = {
        MessagingConsentUpdateStatus_MessagingConsentUpdateStatusUnspecified,
        MessagingConsentUpdateStatus_MessagingConsentUpdateStatusQueued,
        MessagingConsentUpdateStatus_MessagingConsentUpdateStatusCompleted,
        MessagingConsentUpdateStatus_MessagingConsentUpdateStatusInvalidChannelNumber,
        MessagingConsentUpdateStatus_MessagingConsentUpdateStatusDecommissionedCustomerId,
        MessagingConsentUpdateStatus_MessagingConsentUpdateStatusApplicationError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessagingConsentUpdateStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessagingConsentUpdateStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessagingConsentUpdateStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessagingConsentUpdateStatus_MessagingConsentUpdateStatusUnspecified:
    case MessagingConsentUpdateStatus_MessagingConsentUpdateStatusQueued:
    case MessagingConsentUpdateStatus_MessagingConsentUpdateStatusCompleted:
    case MessagingConsentUpdateStatus_MessagingConsentUpdateStatusInvalidChannelNumber:
    case MessagingConsentUpdateStatus_MessagingConsentUpdateStatusDecommissionedCustomerId:
    case MessagingConsentUpdateStatus_MessagingConsentUpdateStatusApplicationError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessagingSessionEndReason

GPBEnumDescriptor *MessagingSessionEndReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MessagingSessionEndReasonUnspecified\000Mes"
        "sagingSessionEndReasonNormalClearing\000Mes"
        "sagingSessionEndReasonInactivity\000Messagi"
        "ngSessionEndReasonFailure\000";
    static const int32_t values[] = {
        MessagingSessionEndReason_MessagingSessionEndReasonUnspecified,
        MessagingSessionEndReason_MessagingSessionEndReasonNormalClearing,
        MessagingSessionEndReason_MessagingSessionEndReasonInactivity,
        MessagingSessionEndReason_MessagingSessionEndReasonFailure,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessagingSessionEndReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessagingSessionEndReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessagingSessionEndReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessagingSessionEndReason_MessagingSessionEndReasonUnspecified:
    case MessagingSessionEndReason_MessagingSessionEndReasonNormalClearing:
    case MessagingSessionEndReason_MessagingSessionEndReasonInactivity:
    case MessagingSessionEndReason_MessagingSessionEndReasonFailure:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessageReaction

GPBEnumDescriptor *MessageReaction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MessageReactionUnspecified\000MessageReacti"
        "onClicked\000MessageReactionUnsubscribed\000Me"
        "ssageReactionComplained\000";
    static const int32_t values[] = {
        MessageReaction_MessageReactionUnspecified,
        MessageReaction_MessageReactionClicked,
        MessageReaction_MessageReactionUnsubscribed,
        MessageReaction_MessageReactionComplained,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageReaction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageReaction_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageReaction_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageReaction_MessageReactionUnspecified:
    case MessageReaction_MessageReactionClicked:
    case MessageReaction_MessageReactionUnsubscribed:
    case MessageReaction_MessageReactionComplained:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PromptMessageReplyAction

GPBEnumDescriptor *PromptMessageReplyAction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PromptMessageReplyActionUnspecified\000Prom"
        "ptMessageReplyActionText\000PromptMessageRe"
        "plyActionPhoneNumber\000PromptMessageReplyA"
        "ctionEmail\000PromptMessageReplyActionLocat"
        "ion\000PromptMessageReplyActionURL\000";
    static const int32_t values[] = {
        PromptMessageReplyAction_PromptMessageReplyActionUnspecified,
        PromptMessageReplyAction_PromptMessageReplyActionText,
        PromptMessageReplyAction_PromptMessageReplyActionPhoneNumber,
        PromptMessageReplyAction_PromptMessageReplyActionEmail,
        PromptMessageReplyAction_PromptMessageReplyActionLocation,
        PromptMessageReplyAction_PromptMessageReplyActionURL,
    };
    static const char *extraTextFormatInfo = "\001\005f\347\345\346\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PromptMessageReplyAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PromptMessageReplyAction_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PromptMessageReplyAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case PromptMessageReplyAction_PromptMessageReplyActionUnspecified:
    case PromptMessageReplyAction_PromptMessageReplyActionText:
    case PromptMessageReplyAction_PromptMessageReplyActionPhoneNumber:
    case PromptMessageReplyAction_PromptMessageReplyActionEmail:
    case PromptMessageReplyAction_PromptMessageReplyActionLocation:
    case PromptMessageReplyAction_PromptMessageReplyActionURL:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessageDeliveryStatus

GPBEnumDescriptor *MessageDeliveryStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MessageDeliveryStatusUnspecified\000Message"
        "DeliveryStatusQueued\000MessageDeliveryStat"
        "usSent\000MessageDeliveryStatusDelivered\000Me"
        "ssageDeliveryStatusRead\000MessageDeliveryS"
        "tatusReceived\000MessageDeliveryStatusSessi"
        "onInitiated\000MessageDeliveryStatusFailed\000"
        "MessageDeliveryStatusNoConsent\000MessageDe"
        "liveryStatusNoCapability\000MessageDelivery"
        "StatusExpired\000MessageDeliveryStatusNoSes"
        "sionInProgress\000MessageDeliveryStatusOthe"
        "rSessionInProgress\000MessageDeliveryStatus"
        "InvalidReplyToken\000MessageDeliveryStatusI"
        "nvalidChannelNumber\000MessageDeliveryStatu"
        "sNotSupported\000MessageDeliveryStatusInval"
        "idReplyToMessageId\000MessageDeliveryStatus"
        "InvalidCustomerId\000MessageDeliveryStatusD"
        "uplicateRequest\000MessageDeliveryStatusTag"
        "NotFound\000MessageDeliveryStatusCustomerNu"
        "mberNotFound\000MessageDeliveryStatusDecomm"
        "issionedCustomerid\000MessageDeliveryStatus"
        "Rejected\000MessageDeliveryStatusInvalidReq"
        "uest\000MessageDeliveryStatusInsufficientCr"
        "edits\000MessageDeliveryStatusGatewayError\000"
        "MessageDeliveryStatusApplicationError\000";
    static const int32_t values[] = {
        MessageDeliveryStatus_MessageDeliveryStatusUnspecified,
        MessageDeliveryStatus_MessageDeliveryStatusQueued,
        MessageDeliveryStatus_MessageDeliveryStatusSent,
        MessageDeliveryStatus_MessageDeliveryStatusDelivered,
        MessageDeliveryStatus_MessageDeliveryStatusRead,
        MessageDeliveryStatus_MessageDeliveryStatusReceived,
        MessageDeliveryStatus_MessageDeliveryStatusSessionInitiated,
        MessageDeliveryStatus_MessageDeliveryStatusFailed,
        MessageDeliveryStatus_MessageDeliveryStatusNoConsent,
        MessageDeliveryStatus_MessageDeliveryStatusNoCapability,
        MessageDeliveryStatus_MessageDeliveryStatusExpired,
        MessageDeliveryStatus_MessageDeliveryStatusNoSessionInProgress,
        MessageDeliveryStatus_MessageDeliveryStatusOtherSessionInProgress,
        MessageDeliveryStatus_MessageDeliveryStatusInvalidReplyToken,
        MessageDeliveryStatus_MessageDeliveryStatusInvalidChannelNumber,
        MessageDeliveryStatus_MessageDeliveryStatusNotSupported,
        MessageDeliveryStatus_MessageDeliveryStatusInvalidReplyToMessageId,
        MessageDeliveryStatus_MessageDeliveryStatusInvalidCustomerId,
        MessageDeliveryStatus_MessageDeliveryStatusDuplicateRequest,
        MessageDeliveryStatus_MessageDeliveryStatusTagNotFound,
        MessageDeliveryStatus_MessageDeliveryStatusCustomerNumberNotFound,
        MessageDeliveryStatus_MessageDeliveryStatusDecommissionedCustomerid,
        MessageDeliveryStatus_MessageDeliveryStatusRejected,
        MessageDeliveryStatus_MessageDeliveryStatusInvalidRequest,
        MessageDeliveryStatus_MessageDeliveryStatusInsufficientCredits,
        MessageDeliveryStatus_MessageDeliveryStatusGatewayError,
        MessageDeliveryStatus_MessageDeliveryStatusApplicationError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageDeliveryStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageDeliveryStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageDeliveryStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageDeliveryStatus_MessageDeliveryStatusUnspecified:
    case MessageDeliveryStatus_MessageDeliveryStatusQueued:
    case MessageDeliveryStatus_MessageDeliveryStatusSent:
    case MessageDeliveryStatus_MessageDeliveryStatusDelivered:
    case MessageDeliveryStatus_MessageDeliveryStatusRead:
    case MessageDeliveryStatus_MessageDeliveryStatusReceived:
    case MessageDeliveryStatus_MessageDeliveryStatusSessionInitiated:
    case MessageDeliveryStatus_MessageDeliveryStatusFailed:
    case MessageDeliveryStatus_MessageDeliveryStatusNoConsent:
    case MessageDeliveryStatus_MessageDeliveryStatusNoCapability:
    case MessageDeliveryStatus_MessageDeliveryStatusExpired:
    case MessageDeliveryStatus_MessageDeliveryStatusNoSessionInProgress:
    case MessageDeliveryStatus_MessageDeliveryStatusOtherSessionInProgress:
    case MessageDeliveryStatus_MessageDeliveryStatusInvalidReplyToken:
    case MessageDeliveryStatus_MessageDeliveryStatusInvalidChannelNumber:
    case MessageDeliveryStatus_MessageDeliveryStatusNotSupported:
    case MessageDeliveryStatus_MessageDeliveryStatusInvalidReplyToMessageId:
    case MessageDeliveryStatus_MessageDeliveryStatusInvalidCustomerId:
    case MessageDeliveryStatus_MessageDeliveryStatusDuplicateRequest:
    case MessageDeliveryStatus_MessageDeliveryStatusTagNotFound:
    case MessageDeliveryStatus_MessageDeliveryStatusCustomerNumberNotFound:
    case MessageDeliveryStatus_MessageDeliveryStatusDecommissionedCustomerid:
    case MessageDeliveryStatus_MessageDeliveryStatusRejected:
    case MessageDeliveryStatus_MessageDeliveryStatusInvalidRequest:
    case MessageDeliveryStatus_MessageDeliveryStatusInsufficientCredits:
    case MessageDeliveryStatus_MessageDeliveryStatusGatewayError:
    case MessageDeliveryStatus_MessageDeliveryStatusApplicationError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum VoiceCallStatus

GPBEnumDescriptor *VoiceCallStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VoiceCallStatusUnspecified\000VoiceCallStat"
        "usQueued\000VoiceCallStatusAnswered\000VoiceCa"
        "llStatusRinging\000VoiceCallStatusActive\000Vo"
        "iceCallStatusDialing\000VoiceCallStatusDial"
        "Completed\000VoiceCallStatusBridged\000VoiceCa"
        "llStatusEnqueued\000VoiceCallStatusDequeued"
        "\000VoiceCallStatusTransferred\000VoiceCallSta"
        "tusTransferCompleted\000VoiceCallStatusComp"
        "leted\000VoiceCallStatusInsufficientCredit\000"
        "VoiceCallStatusNotAnswered\000VoiceCallStat"
        "usInvalidPhoneNumber\000VoiceCallStatusDest"
        "inationNotSupported\000VoiceCallStatusDecom"
        "missionedCustomerid\000VoiceCallStatusExpir"
        "ed\000VoiceCallStatusInvalidChannelNumber\000V"
        "oiceCallStatusGatewayError\000VoiceCallStat"
        "usApplicationError\000";
    static const int32_t values[] = {
        VoiceCallStatus_VoiceCallStatusUnspecified,
        VoiceCallStatus_VoiceCallStatusQueued,
        VoiceCallStatus_VoiceCallStatusAnswered,
        VoiceCallStatus_VoiceCallStatusRinging,
        VoiceCallStatus_VoiceCallStatusActive,
        VoiceCallStatus_VoiceCallStatusDialing,
        VoiceCallStatus_VoiceCallStatusDialCompleted,
        VoiceCallStatus_VoiceCallStatusBridged,
        VoiceCallStatus_VoiceCallStatusEnqueued,
        VoiceCallStatus_VoiceCallStatusDequeued,
        VoiceCallStatus_VoiceCallStatusTransferred,
        VoiceCallStatus_VoiceCallStatusTransferCompleted,
        VoiceCallStatus_VoiceCallStatusCompleted,
        VoiceCallStatus_VoiceCallStatusInsufficientCredit,
        VoiceCallStatus_VoiceCallStatusNotAnswered,
        VoiceCallStatus_VoiceCallStatusInvalidPhoneNumber,
        VoiceCallStatus_VoiceCallStatusDestinationNotSupported,
        VoiceCallStatus_VoiceCallStatusDecommissionedCustomerid,
        VoiceCallStatus_VoiceCallStatusExpired,
        VoiceCallStatus_VoiceCallStatusInvalidChannelNumber,
        VoiceCallStatus_VoiceCallStatusGatewayError,
        VoiceCallStatus_VoiceCallStatusApplicationError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(VoiceCallStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:VoiceCallStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL VoiceCallStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case VoiceCallStatus_VoiceCallStatusUnspecified:
    case VoiceCallStatus_VoiceCallStatusQueued:
    case VoiceCallStatus_VoiceCallStatusAnswered:
    case VoiceCallStatus_VoiceCallStatusRinging:
    case VoiceCallStatus_VoiceCallStatusActive:
    case VoiceCallStatus_VoiceCallStatusDialing:
    case VoiceCallStatus_VoiceCallStatusDialCompleted:
    case VoiceCallStatus_VoiceCallStatusBridged:
    case VoiceCallStatus_VoiceCallStatusEnqueued:
    case VoiceCallStatus_VoiceCallStatusDequeued:
    case VoiceCallStatus_VoiceCallStatusTransferred:
    case VoiceCallStatus_VoiceCallStatusTransferCompleted:
    case VoiceCallStatus_VoiceCallStatusCompleted:
    case VoiceCallStatus_VoiceCallStatusInsufficientCredit:
    case VoiceCallStatus_VoiceCallStatusNotAnswered:
    case VoiceCallStatus_VoiceCallStatusInvalidPhoneNumber:
    case VoiceCallStatus_VoiceCallStatusDestinationNotSupported:
    case VoiceCallStatus_VoiceCallStatusDecommissionedCustomerid:
    case VoiceCallStatus_VoiceCallStatusExpired:
    case VoiceCallStatus_VoiceCallStatusInvalidChannelNumber:
    case VoiceCallStatus_VoiceCallStatusGatewayError:
    case VoiceCallStatus_VoiceCallStatusApplicationError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum VoiceCallHangupCause

GPBEnumDescriptor *VoiceCallHangupCause_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VoiceCallHangupCauseUnspecified\000VoiceCal"
        "lHangupCauseUnallocatedNumber\000VoiceCallH"
        "angupCauseUserBusy\000VoiceCallHangupCauseN"
        "ormalClearing\000VoiceCallHangupCauseNoUser"
        "Response\000VoiceCallHangupCauseNoAnswer\000Vo"
        "iceCallHangupCauseSubscriberAbsent\000Voice"
        "CallHangupCauseCallRejected\000VoiceCallHan"
        "gupCauseNormalUnspecified\000VoiceCallHangu"
        "pCauseNormalTemporaryFailure\000VoiceCallHa"
        "ngupCauseServiceUnavailable\000VoiceCallHan"
        "gupCauseRecoveryOnTimerExpire\000VoiceCallH"
        "angupCauseOriginatorCancel\000VoiceCallHang"
        "upCauseLoseRace\000VoiceCallHangupCauseUser"
        "NotRegistered\000";
    static const int32_t values[] = {
        VoiceCallHangupCause_VoiceCallHangupCauseUnspecified,
        VoiceCallHangupCause_VoiceCallHangupCauseUnallocatedNumber,
        VoiceCallHangupCause_VoiceCallHangupCauseUserBusy,
        VoiceCallHangupCause_VoiceCallHangupCauseNormalClearing,
        VoiceCallHangupCause_VoiceCallHangupCauseNoUserResponse,
        VoiceCallHangupCause_VoiceCallHangupCauseNoAnswer,
        VoiceCallHangupCause_VoiceCallHangupCauseSubscriberAbsent,
        VoiceCallHangupCause_VoiceCallHangupCauseCallRejected,
        VoiceCallHangupCause_VoiceCallHangupCauseNormalUnspecified,
        VoiceCallHangupCause_VoiceCallHangupCauseNormalTemporaryFailure,
        VoiceCallHangupCause_VoiceCallHangupCauseServiceUnavailable,
        VoiceCallHangupCause_VoiceCallHangupCauseRecoveryOnTimerExpire,
        VoiceCallHangupCause_VoiceCallHangupCauseOriginatorCancel,
        VoiceCallHangupCause_VoiceCallHangupCauseLoseRace,
        VoiceCallHangupCause_VoiceCallHangupCauseUserNotRegistered,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(VoiceCallHangupCause)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:VoiceCallHangupCause_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL VoiceCallHangupCause_IsValidValue(int32_t value__) {
  switch (value__) {
    case VoiceCallHangupCause_VoiceCallHangupCauseUnspecified:
    case VoiceCallHangupCause_VoiceCallHangupCauseUnallocatedNumber:
    case VoiceCallHangupCause_VoiceCallHangupCauseUserBusy:
    case VoiceCallHangupCause_VoiceCallHangupCauseNormalClearing:
    case VoiceCallHangupCause_VoiceCallHangupCauseNoUserResponse:
    case VoiceCallHangupCause_VoiceCallHangupCauseNoAnswer:
    case VoiceCallHangupCause_VoiceCallHangupCauseSubscriberAbsent:
    case VoiceCallHangupCause_VoiceCallHangupCauseCallRejected:
    case VoiceCallHangupCause_VoiceCallHangupCauseNormalUnspecified:
    case VoiceCallHangupCause_VoiceCallHangupCauseNormalTemporaryFailure:
    case VoiceCallHangupCause_VoiceCallHangupCauseServiceUnavailable:
    case VoiceCallHangupCause_VoiceCallHangupCauseRecoveryOnTimerExpire:
    case VoiceCallHangupCause_VoiceCallHangupCauseOriginatorCancel:
    case VoiceCallHangupCause_VoiceCallHangupCauseLoseRace:
    case VoiceCallHangupCause_VoiceCallHangupCauseUserNotRegistered:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum UssdSessionStatus

GPBEnumDescriptor *UssdSessionStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UssdSessionStatusUnspecified\000UssdSession"
        "StatusActive\000UssdSessionStatusIncomplete"
        "\000UssdSessionStatusCompleted\000UssdSessionS"
        "tatusAppError\000";
    static const int32_t values[] = {
        UssdSessionStatus_UssdSessionStatusUnspecified,
        UssdSessionStatus_UssdSessionStatusActive,
        UssdSessionStatus_UssdSessionStatusIncomplete,
        UssdSessionStatus_UssdSessionStatusCompleted,
        UssdSessionStatus_UssdSessionStatusAppError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UssdSessionStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UssdSessionStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UssdSessionStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case UssdSessionStatus_UssdSessionStatusUnspecified:
    case UssdSessionStatus_UssdSessionStatusActive:
    case UssdSessionStatus_UssdSessionStatusIncomplete:
    case UssdSessionStatus_UssdSessionStatusCompleted:
    case UssdSessionStatus_UssdSessionStatusAppError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum TextToSpeechVoice

GPBEnumDescriptor *TextToSpeechVoice_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TextToSpeechVoiceUnspecified\000TextToSpeec"
        "hVoiceMale\000TextToSpeechVoiceFemale\000";
    static const int32_t values[] = {
        TextToSpeechVoice_TextToSpeechVoiceUnspecified,
        TextToSpeechVoice_TextToSpeechVoiceMale,
        TextToSpeechVoice_TextToSpeechVoiceFemale,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TextToSpeechVoice)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TextToSpeechVoice_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TextToSpeechVoice_IsValidValue(int32_t value__) {
  switch (value__) {
    case TextToSpeechVoice_TextToSpeechVoiceUnspecified:
    case TextToSpeechVoice_TextToSpeechVoiceMale:
    case TextToSpeechVoice_TextToSpeechVoiceFemale:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessagingChannelNumber

@implementation MessagingChannelNumber

@dynamic channel;
@dynamic number;

typedef struct MessagingChannelNumber__storage_ {
  uint32_t _has_storage_[1];
  MessagingChannel channel;
  NSString *number;
} MessagingChannelNumber__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.enumDescFunc = MessagingChannel_EnumDescriptor,
        .number = MessagingChannelNumber_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessagingChannelNumber__storage_, channel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "number",
        .dataTypeSpecific.clazz = Nil,
        .number = MessagingChannelNumber_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessagingChannelNumber__storage_, number),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessagingChannelNumber class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessagingChannelNumber__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MessagingChannelNumber_Channel_RawValue(MessagingChannelNumber *message) {
  GPBDescriptor *descriptor = [MessagingChannelNumber descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessagingChannelNumber_FieldNumber_Channel];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMessagingChannelNumber_Channel_RawValue(MessagingChannelNumber *message, int32_t value) {
  GPBDescriptor *descriptor = [MessagingChannelNumber descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessagingChannelNumber_FieldNumber_Channel];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MediaMessageBody

@implementation MediaMessageBody

@dynamic URL;
@dynamic media;

typedef struct MediaMessageBody__storage_ {
  uint32_t _has_storage_[1];
  MediaType media;
  NSString *URL;
} MediaMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = MediaMessageBody_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MediaMessageBody__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "media",
        .dataTypeSpecific.enumDescFunc = MediaType_EnumDescriptor,
        .number = MediaMessageBody_FieldNumber_Media,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MediaMessageBody__storage_, media),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MediaMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MediaMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MediaMessageBody_Media_RawValue(MediaMessageBody *message) {
  GPBDescriptor *descriptor = [MediaMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaMessageBody_FieldNumber_Media];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMediaMessageBody_Media_RawValue(MediaMessageBody *message, int32_t value) {
  GPBDescriptor *descriptor = [MediaMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaMessageBody_FieldNumber_Media];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - LocationMessageBody

@implementation LocationMessageBody

@dynamic latitude;
@dynamic longitude;
@dynamic hasLabel, label;
@dynamic hasAddress, address;

typedef struct LocationMessageBody__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *label;
  GPBStringValue *address;
  double latitude;
  double longitude;
} LocationMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.clazz = Nil,
        .number = LocationMessageBody_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LocationMessageBody__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.clazz = Nil,
        .number = LocationMessageBody_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LocationMessageBody__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = LocationMessageBody_FieldNumber_Label,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LocationMessageBody__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = LocationMessageBody_FieldNumber_Address,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LocationMessageBody__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocationMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LocationMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmailMessageBody

@implementation EmailMessageBody

@dynamic subject;
@dynamic bodyPlain;
@dynamic bodyHtml;
@dynamic ccListArray, ccListArray_Count;
@dynamic bccListArray, bccListArray_Count;

typedef struct EmailMessageBody__storage_ {
  uint32_t _has_storage_[1];
  NSString *subject;
  NSString *bodyPlain;
  NSString *bodyHtml;
  NSMutableArray *ccListArray;
  NSMutableArray *bccListArray;
} EmailMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subject",
        .dataTypeSpecific.clazz = Nil,
        .number = EmailMessageBody_FieldNumber_Subject,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmailMessageBody__storage_, subject),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bodyPlain",
        .dataTypeSpecific.clazz = Nil,
        .number = EmailMessageBody_FieldNumber_BodyPlain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmailMessageBody__storage_, bodyPlain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bodyHtml",
        .dataTypeSpecific.clazz = Nil,
        .number = EmailMessageBody_FieldNumber_BodyHtml,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmailMessageBody__storage_, bodyHtml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ccListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EmailMessageBody_FieldNumber_CcListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EmailMessageBody__storage_, ccListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bccListArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EmailMessageBody_FieldNumber_BccListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EmailMessageBody__storage_, bccListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmailMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmailMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TemplateMessageBody

@implementation TemplateMessageBody

@dynamic id_p;
@dynamic params, params_Count;

typedef struct TemplateMessageBody__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSMutableDictionary *params;
} TemplateMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TemplateMessageBody_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TemplateMessageBody__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "params",
        .dataTypeSpecific.clazz = Nil,
        .number = TemplateMessageBody_FieldNumber_Params,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TemplateMessageBody__storage_, params),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TemplateMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TemplateMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SayCallAction

@implementation SayCallAction

@dynamic text;
@dynamic voice;
@dynamic playBeep;

typedef struct SayCallAction__storage_ {
  uint32_t _has_storage_[1];
  TextToSpeechVoice voice;
  NSString *text;
} SayCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = SayCallAction_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SayCallAction__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voice",
        .dataTypeSpecific.enumDescFunc = TextToSpeechVoice_EnumDescriptor,
        .number = SayCallAction_FieldNumber_Voice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SayCallAction__storage_, voice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playBeep",
        .dataTypeSpecific.clazz = Nil,
        .number = SayCallAction_FieldNumber_PlayBeep,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SayCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SayCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SayCallAction_Voice_RawValue(SayCallAction *message) {
  GPBDescriptor *descriptor = [SayCallAction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SayCallAction_FieldNumber_Voice];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSayCallAction_Voice_RawValue(SayCallAction *message, int32_t value) {
  GPBDescriptor *descriptor = [SayCallAction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SayCallAction_FieldNumber_Voice];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - PlayCallAction

@implementation PlayCallAction

@dynamic URL;

typedef struct PlayCallAction__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
} PlayCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = PlayCallAction_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PlayCallAction__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PlayCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PlayCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDigitsCallAction

@implementation GetDigitsCallAction

@dynamic promptOneOfCase;
@dynamic say;
@dynamic play;
@dynamic hasTimeout, timeout;
@dynamic hasFinishOnKey, finishOnKey;
@dynamic hasNumDigits, numDigits;

typedef struct GetDigitsCallAction__storage_ {
  uint32_t _has_storage_[2];
  SayCallAction *say;
  PlayCallAction *play;
  GPBDuration *timeout;
  GPBStringValue *finishOnKey;
  GPBInt32Value *numDigits;
} GetDigitsCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "say",
        .dataTypeSpecific.clazz = GPBObjCClass(SayCallAction),
        .number = GetDigitsCallAction_FieldNumber_Say,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDigitsCallAction__storage_, say),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "play",
        .dataTypeSpecific.clazz = GPBObjCClass(PlayCallAction),
        .number = GetDigitsCallAction_FieldNumber_Play,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetDigitsCallAction__storage_, play),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeout",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = GetDigitsCallAction_FieldNumber_Timeout,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDigitsCallAction__storage_, timeout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "finishOnKey",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = GetDigitsCallAction_FieldNumber_FinishOnKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetDigitsCallAction__storage_, finishOnKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "numDigits",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = GetDigitsCallAction_FieldNumber_NumDigits,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetDigitsCallAction__storage_, numDigits),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDigitsCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDigitsCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "prompt",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetDigitsCallAction_ClearPromptOneOfCase(GetDigitsCallAction *message) {
  GPBDescriptor *descriptor = [GetDigitsCallAction descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetRecordingCallAction

@implementation GetRecordingCallAction

@dynamic promptOneOfCase;
@dynamic say;
@dynamic play;
@dynamic hasTimeout, timeout;
@dynamic hasMaxLength, maxLength;
@dynamic hasFinishOnKey, finishOnKey;
@dynamic playBeep;
@dynamic trimSilence;

typedef struct GetRecordingCallAction__storage_ {
  uint32_t _has_storage_[2];
  SayCallAction *say;
  PlayCallAction *play;
  GPBDuration *timeout;
  GPBDuration *maxLength;
  GPBStringValue *finishOnKey;
} GetRecordingCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "say",
        .dataTypeSpecific.clazz = GPBObjCClass(SayCallAction),
        .number = GetRecordingCallAction_FieldNumber_Say,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetRecordingCallAction__storage_, say),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "play",
        .dataTypeSpecific.clazz = GPBObjCClass(PlayCallAction),
        .number = GetRecordingCallAction_FieldNumber_Play,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetRecordingCallAction__storage_, play),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeout",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = GetRecordingCallAction_FieldNumber_Timeout,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRecordingCallAction__storage_, timeout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxLength",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = GetRecordingCallAction_FieldNumber_MaxLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetRecordingCallAction__storage_, maxLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "finishOnKey",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = GetRecordingCallAction_FieldNumber_FinishOnKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetRecordingCallAction__storage_, finishOnKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "playBeep",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRecordingCallAction_FieldNumber_PlayBeep,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "trimSilence",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRecordingCallAction_FieldNumber_TrimSilence,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRecordingCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRecordingCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "prompt",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetRecordingCallAction_ClearPromptOneOfCase(GetRecordingCallAction *message) {
  GPBDescriptor *descriptor = [GetRecordingCallAction descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - RecordSessionCallAction

@implementation RecordSessionCallAction


typedef struct RecordSessionCallAction__storage_ {
  uint32_t _has_storage_[1];
} RecordSessionCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RecordSessionCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RecordSessionCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DialCallAction

@implementation DialCallAction

@dynamic customerNumbersArray, customerNumbersArray_Count;
@dynamic record;
@dynamic sequential;
@dynamic hasRingbackTone, ringbackTone;
@dynamic hasCallerId, callerId;
@dynamic hasMaxDuration, maxDuration;

typedef struct DialCallAction__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *customerNumbersArray;
  GPBStringValue *ringbackTone;
  GPBStringValue *callerId;
  GPBInt32Value *maxDuration;
} DialCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "customerNumbersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CustomerNumber),
        .number = DialCallAction_FieldNumber_CustomerNumbersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DialCallAction__storage_, customerNumbersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "record",
        .dataTypeSpecific.clazz = Nil,
        .number = DialCallAction_FieldNumber_Record,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sequential",
        .dataTypeSpecific.clazz = Nil,
        .number = DialCallAction_FieldNumber_Sequential,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ringbackTone",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = DialCallAction_FieldNumber_RingbackTone,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DialCallAction__storage_, ringbackTone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "callerId",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = DialCallAction_FieldNumber_CallerId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DialCallAction__storage_, callerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxDuration",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = DialCallAction_FieldNumber_MaxDuration,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DialCallAction__storage_, maxDuration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DialCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DialCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnqueueCallAction

@implementation EnqueueCallAction

@dynamic hasHoldMusic, holdMusic;
@dynamic hasQueueName, queueName;

typedef struct EnqueueCallAction__storage_ {
  uint32_t _has_storage_[1];
  GPBStringValue *holdMusic;
  GPBStringValue *queueName;
} EnqueueCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "holdMusic",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = EnqueueCallAction_FieldNumber_HoldMusic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnqueueCallAction__storage_, holdMusic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "queueName",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = EnqueueCallAction_FieldNumber_QueueName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EnqueueCallAction__storage_, queueName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnqueueCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnqueueCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DequeueCallAction

@implementation DequeueCallAction

@dynamic hasChannelNumber, channelNumber;
@dynamic record;
@dynamic hasQueueName, queueName;

typedef struct DequeueCallAction__storage_ {
  uint32_t _has_storage_[1];
  MessagingChannelNumber *channelNumber;
  GPBStringValue *queueName;
} DequeueCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelNumber",
        .dataTypeSpecific.clazz = GPBObjCClass(MessagingChannelNumber),
        .number = DequeueCallAction_FieldNumber_ChannelNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DequeueCallAction__storage_, channelNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "record",
        .dataTypeSpecific.clazz = Nil,
        .number = DequeueCallAction_FieldNumber_Record,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "queueName",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = DequeueCallAction_FieldNumber_QueueName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DequeueCallAction__storage_, queueName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DequeueCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DequeueCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RejectCallAction

@implementation RejectCallAction


typedef struct RejectCallAction__storage_ {
  uint32_t _has_storage_[1];
} RejectCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RejectCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RejectCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedirectCallAction

@implementation RedirectCallAction

@dynamic URL;

typedef struct RedirectCallAction__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
} RedirectCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = RedirectCallAction_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedirectCallAction__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedirectCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedirectCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceCallAction

@implementation VoiceCallAction

@dynamic entryOneOfCase;
@dynamic say;
@dynamic play;
@dynamic getDigits;
@dynamic dial;
@dynamic recordSession;
@dynamic getRecording;
@dynamic enqueue;
@dynamic dequeue;
@dynamic reject;
@dynamic redirect;

typedef struct VoiceCallAction__storage_ {
  uint32_t _has_storage_[2];
  SayCallAction *say;
  PlayCallAction *play;
  GetDigitsCallAction *getDigits;
  DialCallAction *dial;
  RecordSessionCallAction *recordSession;
  GetRecordingCallAction *getRecording;
  EnqueueCallAction *enqueue;
  DequeueCallAction *dequeue;
  RejectCallAction *reject;
  RedirectCallAction *redirect;
} VoiceCallAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "say",
        .dataTypeSpecific.clazz = GPBObjCClass(SayCallAction),
        .number = VoiceCallAction_FieldNumber_Say,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, say),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "play",
        .dataTypeSpecific.clazz = GPBObjCClass(PlayCallAction),
        .number = VoiceCallAction_FieldNumber_Play,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, play),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getDigits",
        .dataTypeSpecific.clazz = GPBObjCClass(GetDigitsCallAction),
        .number = VoiceCallAction_FieldNumber_GetDigits,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, getDigits),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dial",
        .dataTypeSpecific.clazz = GPBObjCClass(DialCallAction),
        .number = VoiceCallAction_FieldNumber_Dial,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, dial),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recordSession",
        .dataTypeSpecific.clazz = GPBObjCClass(RecordSessionCallAction),
        .number = VoiceCallAction_FieldNumber_RecordSession,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, recordSession),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getRecording",
        .dataTypeSpecific.clazz = GPBObjCClass(GetRecordingCallAction),
        .number = VoiceCallAction_FieldNumber_GetRecording,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, getRecording),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "enqueue",
        .dataTypeSpecific.clazz = GPBObjCClass(EnqueueCallAction),
        .number = VoiceCallAction_FieldNumber_Enqueue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, enqueue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dequeue",
        .dataTypeSpecific.clazz = GPBObjCClass(DequeueCallAction),
        .number = VoiceCallAction_FieldNumber_Dequeue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, dequeue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reject",
        .dataTypeSpecific.clazz = GPBObjCClass(RejectCallAction),
        .number = VoiceCallAction_FieldNumber_Reject,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, reject),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "redirect",
        .dataTypeSpecific.clazz = GPBObjCClass(RedirectCallAction),
        .number = VoiceCallAction_FieldNumber_Redirect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VoiceCallAction__storage_, redirect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceCallAction class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceCallAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "entry",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void VoiceCallAction_ClearEntryOneOfCase(VoiceCallAction *message) {
  GPBDescriptor *descriptor = [VoiceCallAction descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - VoiceCallDialplanMessageBody

@implementation VoiceCallDialplanMessageBody

@dynamic actionsArray, actionsArray_Count;

typedef struct VoiceCallDialplanMessageBody__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *actionsArray;
} VoiceCallDialplanMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "actionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(VoiceCallAction),
        .number = VoiceCallDialplanMessageBody_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VoiceCallDialplanMessageBody__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceCallDialplanMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceCallDialplanMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceCallDialInput

@implementation VoiceCallDialInput

@dynamic destinationNumber;
@dynamic hasStartedAt, startedAt;
@dynamic hasDuration, duration;

typedef struct VoiceCallDialInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *destinationNumber;
  GPBTimestamp *startedAt;
  GPBDuration *duration;
} VoiceCallDialInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "destinationNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = VoiceCallDialInput_FieldNumber_DestinationNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceCallDialInput__storage_, destinationNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startedAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = VoiceCallDialInput_FieldNumber_StartedAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoiceCallDialInput__storage_, startedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = VoiceCallDialInput_FieldNumber_Duration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VoiceCallDialInput__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceCallDialInput class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceCallDialInput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceCallQueueInput

@implementation VoiceCallQueueInput

@dynamic hasEnqueuedAt, enqueuedAt;
@dynamic hasDequeuedAt, dequeuedAt;
@dynamic hasDequeuedToNumber, dequeuedToNumber;
@dynamic hasDequeuedToSessionId, dequeuedToSessionId;
@dynamic hasQueueDuration, queueDuration;

typedef struct VoiceCallQueueInput__storage_ {
  uint32_t _has_storage_[1];
  GPBTimestamp *enqueuedAt;
  GPBTimestamp *dequeuedAt;
  GPBStringValue *dequeuedToNumber;
  GPBStringValue *dequeuedToSessionId;
  GPBDuration *queueDuration;
} VoiceCallQueueInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "enqueuedAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = VoiceCallQueueInput_FieldNumber_EnqueuedAt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceCallQueueInput__storage_, enqueuedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dequeuedAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = VoiceCallQueueInput_FieldNumber_DequeuedAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoiceCallQueueInput__storage_, dequeuedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dequeuedToNumber",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = VoiceCallQueueInput_FieldNumber_DequeuedToNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VoiceCallQueueInput__storage_, dequeuedToNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dequeuedToSessionId",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = VoiceCallQueueInput_FieldNumber_DequeuedToSessionId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VoiceCallQueueInput__storage_, dequeuedToSessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "queueDuration",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = VoiceCallQueueInput_FieldNumber_QueueDuration,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VoiceCallQueueInput__storage_, queueDuration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceCallQueueInput class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceCallQueueInput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\010\242\251\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceCallInputMessageBody

@implementation VoiceCallInputMessageBody

@dynamic direction;
@dynamic status;
@dynamic hasStartedAt, startedAt;
@dynamic hangupCause;
@dynamic hasDtmfDigits, dtmfDigits;
@dynamic hasRecordingURL, recordingURL;
@dynamic hasDialData, dialData;
@dynamic hasQueueData, queueData;

typedef struct VoiceCallInputMessageBody__storage_ {
  uint32_t _has_storage_[1];
  CustomerEventDirection direction;
  VoiceCallStatus status;
  VoiceCallHangupCause hangupCause;
  GPBTimestamp *startedAt;
  GPBStringValue *dtmfDigits;
  GPBStringValue *recordingURL;
  VoiceCallDialInput *dialData;
  VoiceCallQueueInput *queueData;
} VoiceCallInputMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "direction",
        .dataTypeSpecific.enumDescFunc = CustomerEventDirection_EnumDescriptor,
        .number = VoiceCallInputMessageBody_FieldNumber_Direction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceCallInputMessageBody__storage_, direction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = VoiceCallStatus_EnumDescriptor,
        .number = VoiceCallInputMessageBody_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoiceCallInputMessageBody__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startedAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = VoiceCallInputMessageBody_FieldNumber_StartedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VoiceCallInputMessageBody__storage_, startedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hangupCause",
        .dataTypeSpecific.enumDescFunc = VoiceCallHangupCause_EnumDescriptor,
        .number = VoiceCallInputMessageBody_FieldNumber_HangupCause,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VoiceCallInputMessageBody__storage_, hangupCause),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dtmfDigits",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = VoiceCallInputMessageBody_FieldNumber_DtmfDigits,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VoiceCallInputMessageBody__storage_, dtmfDigits),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recordingURL",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = VoiceCallInputMessageBody_FieldNumber_RecordingURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VoiceCallInputMessageBody__storage_, recordingURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dialData",
        .dataTypeSpecific.clazz = GPBObjCClass(VoiceCallDialInput),
        .number = VoiceCallInputMessageBody_FieldNumber_DialData,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VoiceCallInputMessageBody__storage_, dialData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "queueData",
        .dataTypeSpecific.clazz = GPBObjCClass(VoiceCallQueueInput),
        .number = VoiceCallInputMessageBody_FieldNumber_QueueData,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VoiceCallInputMessageBody__storage_, queueData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceCallInputMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceCallInputMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006\t\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t VoiceCallInputMessageBody_Direction_RawValue(VoiceCallInputMessageBody *message) {
  GPBDescriptor *descriptor = [VoiceCallInputMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VoiceCallInputMessageBody_FieldNumber_Direction];
  return GPBGetMessageRawEnumField(message, field);
}

void SetVoiceCallInputMessageBody_Direction_RawValue(VoiceCallInputMessageBody *message, int32_t value) {
  GPBDescriptor *descriptor = [VoiceCallInputMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VoiceCallInputMessageBody_FieldNumber_Direction];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t VoiceCallInputMessageBody_Status_RawValue(VoiceCallInputMessageBody *message) {
  GPBDescriptor *descriptor = [VoiceCallInputMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VoiceCallInputMessageBody_FieldNumber_Status];
  return GPBGetMessageRawEnumField(message, field);
}

void SetVoiceCallInputMessageBody_Status_RawValue(VoiceCallInputMessageBody *message, int32_t value) {
  GPBDescriptor *descriptor = [VoiceCallInputMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VoiceCallInputMessageBody_FieldNumber_Status];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t VoiceCallInputMessageBody_HangupCause_RawValue(VoiceCallInputMessageBody *message) {
  GPBDescriptor *descriptor = [VoiceCallInputMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VoiceCallInputMessageBody_FieldNumber_HangupCause];
  return GPBGetMessageRawEnumField(message, field);
}

void SetVoiceCallInputMessageBody_HangupCause_RawValue(VoiceCallInputMessageBody *message, int32_t value) {
  GPBDescriptor *descriptor = [VoiceCallInputMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VoiceCallInputMessageBody_FieldNumber_HangupCause];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UssdInputMessageBody

@implementation UssdInputMessageBody

@dynamic status;
@dynamic hasText, text;

typedef struct UssdInputMessageBody__storage_ {
  uint32_t _has_storage_[1];
  UssdSessionStatus status;
  GPBStringValue *text;
} UssdInputMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = UssdSessionStatus_EnumDescriptor,
        .number = UssdInputMessageBody_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UssdInputMessageBody__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = UssdInputMessageBody_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UssdInputMessageBody__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UssdInputMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UssdInputMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UssdInputMessageBody_Status_RawValue(UssdInputMessageBody *message) {
  GPBDescriptor *descriptor = [UssdInputMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UssdInputMessageBody_FieldNumber_Status];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUssdInputMessageBody_Status_RawValue(UssdInputMessageBody *message, int32_t value) {
  GPBDescriptor *descriptor = [UssdInputMessageBody descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UssdInputMessageBody_FieldNumber_Status];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UssdMenuMessageBody

@implementation UssdMenuMessageBody

@dynamic text;
@dynamic isTerminal;

typedef struct UssdMenuMessageBody__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} UssdMenuMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = UssdMenuMessageBody_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UssdMenuMessageBody__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isTerminal",
        .dataTypeSpecific.clazz = Nil,
        .number = UssdMenuMessageBody_FieldNumber_IsTerminal,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UssdMenuMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UssdMenuMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OutboundMessageBody

@implementation OutboundMessageBody

@dynamic entryOneOfCase;
@dynamic text;
@dynamic media;
@dynamic location;
@dynamic email;
@dynamic template_p;
@dynamic URL;
@dynamic voice;
@dynamic ussd;

typedef struct OutboundMessageBody__storage_ {
  uint32_t _has_storage_[2];
  NSString *text;
  MediaMessageBody *media;
  LocationMessageBody *location;
  EmailMessageBody *email;
  TemplateMessageBody *template_p;
  NSString *URL;
  VoiceCallDialplanMessageBody *voice;
  UssdMenuMessageBody *ussd;
} OutboundMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = OutboundMessageBody_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OutboundMessageBody__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "media",
        .dataTypeSpecific.clazz = GPBObjCClass(MediaMessageBody),
        .number = OutboundMessageBody_FieldNumber_Media,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OutboundMessageBody__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "location",
        .dataTypeSpecific.clazz = GPBObjCClass(LocationMessageBody),
        .number = OutboundMessageBody_FieldNumber_Location,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OutboundMessageBody__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "email",
        .dataTypeSpecific.clazz = GPBObjCClass(EmailMessageBody),
        .number = OutboundMessageBody_FieldNumber_Email,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OutboundMessageBody__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "template_p",
        .dataTypeSpecific.clazz = GPBObjCClass(TemplateMessageBody),
        .number = OutboundMessageBody_FieldNumber_Template_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OutboundMessageBody__storage_, template_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = OutboundMessageBody_FieldNumber_URL,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OutboundMessageBody__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voice",
        .dataTypeSpecific.clazz = GPBObjCClass(VoiceCallDialplanMessageBody),
        .number = OutboundMessageBody_FieldNumber_Voice,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OutboundMessageBody__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ussd",
        .dataTypeSpecific.clazz = GPBObjCClass(UssdMenuMessageBody),
        .number = OutboundMessageBody_FieldNumber_Ussd,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OutboundMessageBody__storage_, ussd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OutboundMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OutboundMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "entry",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void OutboundMessageBody_ClearEntryOneOfCase(OutboundMessageBody *message) {
  GPBDescriptor *descriptor = [OutboundMessageBody descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - PromptMessageMenuItemBody

@implementation PromptMessageMenuItemBody

@dynamic entryOneOfCase;
@dynamic text;
@dynamic media;

typedef struct PromptMessageMenuItemBody__storage_ {
  uint32_t _has_storage_[2];
  NSString *text;
  MediaMessageBody *media;
} PromptMessageMenuItemBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = PromptMessageMenuItemBody_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PromptMessageMenuItemBody__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "media",
        .dataTypeSpecific.clazz = GPBObjCClass(MediaMessageBody),
        .number = PromptMessageMenuItemBody_FieldNumber_Media,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PromptMessageMenuItemBody__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PromptMessageMenuItemBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PromptMessageMenuItemBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "entry",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void PromptMessageMenuItemBody_ClearEntryOneOfCase(PromptMessageMenuItemBody *message) {
  GPBDescriptor *descriptor = [PromptMessageMenuItemBody descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - InboundMessageBody

@implementation InboundMessageBody

@dynamic entryOneOfCase;
@dynamic text;
@dynamic media;
@dynamic location;
@dynamic email;
@dynamic voice;
@dynamic ussd;

typedef struct InboundMessageBody__storage_ {
  uint32_t _has_storage_[2];
  NSString *text;
  MediaMessageBody *media;
  LocationMessageBody *location;
  EmailMessageBody *email;
  VoiceCallInputMessageBody *voice;
  UssdInputMessageBody *ussd;
} InboundMessageBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = InboundMessageBody_FieldNumber_Text,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InboundMessageBody__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "media",
        .dataTypeSpecific.clazz = GPBObjCClass(MediaMessageBody),
        .number = InboundMessageBody_FieldNumber_Media,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InboundMessageBody__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "location",
        .dataTypeSpecific.clazz = GPBObjCClass(LocationMessageBody),
        .number = InboundMessageBody_FieldNumber_Location,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InboundMessageBody__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "email",
        .dataTypeSpecific.clazz = GPBObjCClass(EmailMessageBody),
        .number = InboundMessageBody_FieldNumber_Email,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InboundMessageBody__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voice",
        .dataTypeSpecific.clazz = GPBObjCClass(VoiceCallInputMessageBody),
        .number = InboundMessageBody_FieldNumber_Voice,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InboundMessageBody__storage_, voice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ussd",
        .dataTypeSpecific.clazz = GPBObjCClass(UssdInputMessageBody),
        .number = InboundMessageBody_FieldNumber_Ussd,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(InboundMessageBody__storage_, ussd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InboundMessageBody class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InboundMessageBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "entry",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void InboundMessageBody_ClearEntryOneOfCase(InboundMessageBody *message) {
  GPBDescriptor *descriptor = [InboundMessageBody descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - OutboundMessageReplyPrompt

@implementation OutboundMessageReplyPrompt

@dynamic action;
@dynamic menuArray, menuArray_Count;

typedef struct OutboundMessageReplyPrompt__storage_ {
  uint32_t _has_storage_[1];
  PromptMessageReplyAction action;
  NSMutableArray *menuArray;
} OutboundMessageReplyPrompt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = PromptMessageReplyAction_EnumDescriptor,
        .number = OutboundMessageReplyPrompt_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OutboundMessageReplyPrompt__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "menuArray",
        .dataTypeSpecific.clazz = GPBObjCClass(PromptMessageMenuItemBody),
        .number = OutboundMessageReplyPrompt_FieldNumber_MenuArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OutboundMessageReplyPrompt__storage_, menuArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OutboundMessageReplyPrompt class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OutboundMessageReplyPrompt__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OutboundMessageReplyPrompt_Action_RawValue(OutboundMessageReplyPrompt *message) {
  GPBDescriptor *descriptor = [OutboundMessageReplyPrompt descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OutboundMessageReplyPrompt_FieldNumber_Action];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOutboundMessageReplyPrompt_Action_RawValue(OutboundMessageReplyPrompt *message, int32_t value) {
  GPBDescriptor *descriptor = [OutboundMessageReplyPrompt descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OutboundMessageReplyPrompt_FieldNumber_Action];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - OutboundMessage

@implementation OutboundMessage

@dynamic hasBody, body;
@dynamic labelsArray, labelsArray_Count;
@dynamic hasProviderTag, providerTag;
@dynamic hasReplyToken, replyToken;
@dynamic hasReplyPrompt, replyPrompt;

typedef struct OutboundMessage__storage_ {
  uint32_t _has_storage_[1];
  OutboundMessageBody *body;
  NSMutableArray *labelsArray;
  GPBStringValue *providerTag;
  GPBStringValue *replyToken;
  OutboundMessageReplyPrompt *replyPrompt;
} OutboundMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "body",
        .dataTypeSpecific.clazz = GPBObjCClass(OutboundMessageBody),
        .number = OutboundMessage_FieldNumber_Body,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OutboundMessage__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "labelsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = OutboundMessage_FieldNumber_LabelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OutboundMessage__storage_, labelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "providerTag",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = OutboundMessage_FieldNumber_ProviderTag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OutboundMessage__storage_, providerTag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replyToken",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = OutboundMessage_FieldNumber_ReplyToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OutboundMessage__storage_, replyToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replyPrompt",
        .dataTypeSpecific.clazz = GPBObjCClass(OutboundMessageReplyPrompt),
        .number = OutboundMessage_FieldNumber_ReplyPrompt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OutboundMessage__storage_, replyPrompt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OutboundMessage class]
                                     rootClass:[MessagingModelRoot class]
                                          file:MessagingModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OutboundMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
