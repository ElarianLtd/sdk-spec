// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: payment_model.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_payment_5fmodel_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_payment_5fmodel_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "common_model.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_payment_5fmodel_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_payment_5fmodel_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_payment_5fmodel_2eproto;
namespace com {
namespace elarian {
namespace hera {
namespace proto {
class PaymentBalance;
class PaymentBalanceDefaultTypeInternal;
extern PaymentBalanceDefaultTypeInternal _PaymentBalance_default_instance_;
class PaymentBalance_PendingEntry_DoNotUse;
class PaymentBalance_PendingEntry_DoNotUseDefaultTypeInternal;
extern PaymentBalance_PendingEntry_DoNotUseDefaultTypeInternal _PaymentBalance_PendingEntry_DoNotUse_default_instance_;
class PaymentChannelCounterParty;
class PaymentChannelCounterPartyDefaultTypeInternal;
extern PaymentChannelCounterPartyDefaultTypeInternal _PaymentChannelCounterParty_default_instance_;
class PaymentChannelNumber;
class PaymentChannelNumberDefaultTypeInternal;
extern PaymentChannelNumberDefaultTypeInternal _PaymentChannelNumber_default_instance_;
class PaymentCounterParty;
class PaymentCounterPartyDefaultTypeInternal;
extern PaymentCounterPartyDefaultTypeInternal _PaymentCounterParty_default_instance_;
class PaymentCustomerCounterParty;
class PaymentCustomerCounterPartyDefaultTypeInternal;
extern PaymentCustomerCounterPartyDefaultTypeInternal _PaymentCustomerCounterParty_default_instance_;
class PaymentPurseCounterParty;
class PaymentPurseCounterPartyDefaultTypeInternal;
extern PaymentPurseCounterPartyDefaultTypeInternal _PaymentPurseCounterParty_default_instance_;
class PaymentTransaction;
class PaymentTransactionDefaultTypeInternal;
extern PaymentTransactionDefaultTypeInternal _PaymentTransaction_default_instance_;
class PaymentWalletCounterParty;
class PaymentWalletCounterPartyDefaultTypeInternal;
extern PaymentWalletCounterPartyDefaultTypeInternal _PaymentWalletCounterParty_default_instance_;
class PendingPaymentTransaction;
class PendingPaymentTransactionDefaultTypeInternal;
extern PendingPaymentTransactionDefaultTypeInternal _PendingPaymentTransaction_default_instance_;
}  // namespace proto
}  // namespace hera
}  // namespace elarian
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::elarian::hera::proto::PaymentBalance* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PaymentBalance>(Arena*);
template<> ::com::elarian::hera::proto::PaymentBalance_PendingEntry_DoNotUse* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PaymentBalance_PendingEntry_DoNotUse>(Arena*);
template<> ::com::elarian::hera::proto::PaymentChannelCounterParty* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PaymentChannelCounterParty>(Arena*);
template<> ::com::elarian::hera::proto::PaymentChannelNumber* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PaymentChannelNumber>(Arena*);
template<> ::com::elarian::hera::proto::PaymentCounterParty* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PaymentCounterParty>(Arena*);
template<> ::com::elarian::hera::proto::PaymentCustomerCounterParty* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PaymentCustomerCounterParty>(Arena*);
template<> ::com::elarian::hera::proto::PaymentPurseCounterParty* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PaymentPurseCounterParty>(Arena*);
template<> ::com::elarian::hera::proto::PaymentTransaction* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PaymentTransaction>(Arena*);
template<> ::com::elarian::hera::proto::PaymentWalletCounterParty* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PaymentWalletCounterParty>(Arena*);
template<> ::com::elarian::hera::proto::PendingPaymentTransaction* Arena::CreateMaybeMessage<::com::elarian::hera::proto::PendingPaymentTransaction>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace elarian {
namespace hera {
namespace proto {

enum PaymentChannel : int {
  PAYMENT_CHANNEL_UNSPECIFIED = 0,
  PAYMENT_CHANNEL_CELLULAR = 1,
  PAYMENT_CHANNEL_AIRTIME = 2,
  PaymentChannel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PaymentChannel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PaymentChannel_IsValid(int value);
constexpr PaymentChannel PaymentChannel_MIN = PAYMENT_CHANNEL_UNSPECIFIED;
constexpr PaymentChannel PaymentChannel_MAX = PAYMENT_CHANNEL_AIRTIME;
constexpr int PaymentChannel_ARRAYSIZE = PaymentChannel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaymentChannel_descriptor();
template<typename T>
inline const std::string& PaymentChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaymentChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaymentChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaymentChannel_descriptor(), enum_t_value);
}
inline bool PaymentChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaymentChannel>(
    PaymentChannel_descriptor(), name, value);
}
enum PaymentStatus : int {
  PAYMENT_STATUS_UNSPECIFIED = 0,
  PAYMENT_STATUS_QUEUED = 100,
  PAYMENT_STATUS_PENDING_CONFIRMATION = 101,
  PAYMENT_STATUS_PENDING_VALIDATION = 102,
  PAYMENT_STATUS_VALIDATED = 103,
  PAYMENT_STATUS_INVALID_REQUEST = 200,
  PAYMENT_STATUS_NOT_SUPPORTED = 201,
  PAYMENT_STATUS_INSUFFICIENT_FUNDS = 202,
  PAYMENT_STATUS_APPLICATION_ERROR = 203,
  PAYMENT_STATUS_NOT_ALLOWED = 204,
  PAYMENT_STATUS_DUPLICATE_REQUEST = 205,
  PAYMENT_STATUS_INVALID_PURSE = 206,
  PAYMENT_STATUS_INVALID_WALLET = 207,
  PAYMENT_STATUS_DECOMMISSIONED_CUSTOMER_ID = 299,
  PAYMENT_STATUS_SUCCESS = 300,
  PAYMENT_STATUS_FAILED = 400,
  PAYMENT_STATUS_THROTTLED = 401,
  PAYMENT_STATUS_EXPIRED = 402,
  PAYMENT_STATUS_REJECTED = 403,
  PAYMENT_STATUS_REVERSED = 500,
  PaymentStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PaymentStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PaymentStatus_IsValid(int value);
constexpr PaymentStatus PaymentStatus_MIN = PAYMENT_STATUS_UNSPECIFIED;
constexpr PaymentStatus PaymentStatus_MAX = PAYMENT_STATUS_REVERSED;
constexpr int PaymentStatus_ARRAYSIZE = PaymentStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaymentStatus_descriptor();
template<typename T>
inline const std::string& PaymentStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaymentStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaymentStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaymentStatus_descriptor(), enum_t_value);
}
inline bool PaymentStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaymentStatus>(
    PaymentStatus_descriptor(), name, value);
}
// ===================================================================

class PaymentChannelNumber PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.PaymentChannelNumber) */ {
 public:
  inline PaymentChannelNumber() : PaymentChannelNumber(nullptr) {}
  virtual ~PaymentChannelNumber();

  PaymentChannelNumber(const PaymentChannelNumber& from);
  PaymentChannelNumber(PaymentChannelNumber&& from) noexcept
    : PaymentChannelNumber() {
    *this = ::std::move(from);
  }

  inline PaymentChannelNumber& operator=(const PaymentChannelNumber& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentChannelNumber& operator=(PaymentChannelNumber&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentChannelNumber& default_instance();

  static inline const PaymentChannelNumber* internal_default_instance() {
    return reinterpret_cast<const PaymentChannelNumber*>(
               &_PaymentChannelNumber_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PaymentChannelNumber& a, PaymentChannelNumber& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentChannelNumber* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentChannelNumber* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentChannelNumber* New() const final {
    return CreateMaybeMessage<PaymentChannelNumber>(nullptr);
  }

  PaymentChannelNumber* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentChannelNumber>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentChannelNumber& from);
  void MergeFrom(const PaymentChannelNumber& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentChannelNumber* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.PaymentChannelNumber";
  }
  protected:
  explicit PaymentChannelNumber(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 2,
    kChannelFieldNumber = 1,
  };
  // string number = 2;
  void clear_number();
  const std::string& number() const;
  void set_number(const std::string& value);
  void set_number(std::string&& value);
  void set_number(const char* value);
  void set_number(const char* value, size_t size);
  std::string* mutable_number();
  std::string* release_number();
  void set_allocated_number(std::string* number);
  private:
  const std::string& _internal_number() const;
  void _internal_set_number(const std::string& value);
  std::string* _internal_mutable_number();
  public:

  // .com.elarian.hera.proto.PaymentChannel channel = 1;
  void clear_channel();
  ::com::elarian::hera::proto::PaymentChannel channel() const;
  void set_channel(::com::elarian::hera::proto::PaymentChannel value);
  private:
  ::com::elarian::hera::proto::PaymentChannel _internal_channel() const;
  void _internal_set_channel(::com::elarian::hera::proto::PaymentChannel value);
  public:

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.PaymentChannelNumber)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_;
  int channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PendingPaymentTransaction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.PendingPaymentTransaction) */ {
 public:
  inline PendingPaymentTransaction() : PendingPaymentTransaction(nullptr) {}
  virtual ~PendingPaymentTransaction();

  PendingPaymentTransaction(const PendingPaymentTransaction& from);
  PendingPaymentTransaction(PendingPaymentTransaction&& from) noexcept
    : PendingPaymentTransaction() {
    *this = ::std::move(from);
  }

  inline PendingPaymentTransaction& operator=(const PendingPaymentTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline PendingPaymentTransaction& operator=(PendingPaymentTransaction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PendingPaymentTransaction& default_instance();

  static inline const PendingPaymentTransaction* internal_default_instance() {
    return reinterpret_cast<const PendingPaymentTransaction*>(
               &_PendingPaymentTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PendingPaymentTransaction& a, PendingPaymentTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(PendingPaymentTransaction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PendingPaymentTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PendingPaymentTransaction* New() const final {
    return CreateMaybeMessage<PendingPaymentTransaction>(nullptr);
  }

  PendingPaymentTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PendingPaymentTransaction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PendingPaymentTransaction& from);
  void MergeFrom(const PendingPaymentTransaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PendingPaymentTransaction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.PendingPaymentTransaction";
  }
  protected:
  explicit PendingPaymentTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatedAtFieldNumber = 1,
    kValueFieldNumber = 2,
    kConvertedFieldNumber = 3,
  };
  // .google.protobuf.Timestamp created_at = 1;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .com.elarian.hera.proto.Cash value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::com::elarian::hera::proto::Cash& value() const;
  ::com::elarian::hera::proto::Cash* release_value();
  ::com::elarian::hera::proto::Cash* mutable_value();
  void set_allocated_value(::com::elarian::hera::proto::Cash* value);
  private:
  const ::com::elarian::hera::proto::Cash& _internal_value() const;
  ::com::elarian::hera::proto::Cash* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::com::elarian::hera::proto::Cash* value);
  ::com::elarian::hera::proto::Cash* unsafe_arena_release_value();

  // .com.elarian.hera.proto.Cash converted = 3;
  bool has_converted() const;
  private:
  bool _internal_has_converted() const;
  public:
  void clear_converted();
  const ::com::elarian::hera::proto::Cash& converted() const;
  ::com::elarian::hera::proto::Cash* release_converted();
  ::com::elarian::hera::proto::Cash* mutable_converted();
  void set_allocated_converted(::com::elarian::hera::proto::Cash* converted);
  private:
  const ::com::elarian::hera::proto::Cash& _internal_converted() const;
  ::com::elarian::hera::proto::Cash* _internal_mutable_converted();
  public:
  void unsafe_arena_set_allocated_converted(
      ::com::elarian::hera::proto::Cash* converted);
  ::com::elarian::hera::proto::Cash* unsafe_arena_release_converted();

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.PendingPaymentTransaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  ::com::elarian::hera::proto::Cash* value_;
  ::com::elarian::hera::proto::Cash* converted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PaymentBalance_PendingEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PaymentBalance_PendingEntry_DoNotUse, 
    std::string, ::com::elarian::hera::proto::PendingPaymentTransaction,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PaymentBalance_PendingEntry_DoNotUse, 
    std::string, ::com::elarian::hera::proto::PendingPaymentTransaction,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PaymentBalance_PendingEntry_DoNotUse();
  explicit PaymentBalance_PendingEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PaymentBalance_PendingEntry_DoNotUse& other);
  static const PaymentBalance_PendingEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PaymentBalance_PendingEntry_DoNotUse*>(&_PaymentBalance_PendingEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "com.elarian.hera.proto.PaymentBalance.PendingEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[2];
  }

  public:
};

// -------------------------------------------------------------------

class PaymentBalance PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.PaymentBalance) */ {
 public:
  inline PaymentBalance() : PaymentBalance(nullptr) {}
  virtual ~PaymentBalance();

  PaymentBalance(const PaymentBalance& from);
  PaymentBalance(PaymentBalance&& from) noexcept
    : PaymentBalance() {
    *this = ::std::move(from);
  }

  inline PaymentBalance& operator=(const PaymentBalance& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentBalance& operator=(PaymentBalance&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentBalance& default_instance();

  static inline const PaymentBalance* internal_default_instance() {
    return reinterpret_cast<const PaymentBalance*>(
               &_PaymentBalance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PaymentBalance& a, PaymentBalance& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentBalance* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentBalance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentBalance* New() const final {
    return CreateMaybeMessage<PaymentBalance>(nullptr);
  }

  PaymentBalance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentBalance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentBalance& from);
  void MergeFrom(const PaymentBalance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentBalance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.PaymentBalance";
  }
  protected:
  explicit PaymentBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPendingFieldNumber = 4,
    kCurrencyCodeFieldNumber = 1,
    kAvailableFieldNumber = 2,
    kActualFieldNumber = 3,
    kSequenceNrFieldNumber = 5,
  };
  // map<string, .com.elarian.hera.proto.PendingPaymentTransaction> pending = 4;
  int pending_size() const;
  private:
  int _internal_pending_size() const;
  public:
  void clear_pending();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::elarian::hera::proto::PendingPaymentTransaction >&
      _internal_pending() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::elarian::hera::proto::PendingPaymentTransaction >*
      _internal_mutable_pending();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::elarian::hera::proto::PendingPaymentTransaction >&
      pending() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::elarian::hera::proto::PendingPaymentTransaction >*
      mutable_pending();

  // string currency_code = 1;
  void clear_currency_code();
  const std::string& currency_code() const;
  void set_currency_code(const std::string& value);
  void set_currency_code(std::string&& value);
  void set_currency_code(const char* value);
  void set_currency_code(const char* value, size_t size);
  std::string* mutable_currency_code();
  std::string* release_currency_code();
  void set_allocated_currency_code(std::string* currency_code);
  private:
  const std::string& _internal_currency_code() const;
  void _internal_set_currency_code(const std::string& value);
  std::string* _internal_mutable_currency_code();
  public:

  // .com.elarian.hera.proto.Cash available = 2;
  bool has_available() const;
  private:
  bool _internal_has_available() const;
  public:
  void clear_available();
  const ::com::elarian::hera::proto::Cash& available() const;
  ::com::elarian::hera::proto::Cash* release_available();
  ::com::elarian::hera::proto::Cash* mutable_available();
  void set_allocated_available(::com::elarian::hera::proto::Cash* available);
  private:
  const ::com::elarian::hera::proto::Cash& _internal_available() const;
  ::com::elarian::hera::proto::Cash* _internal_mutable_available();
  public:
  void unsafe_arena_set_allocated_available(
      ::com::elarian::hera::proto::Cash* available);
  ::com::elarian::hera::proto::Cash* unsafe_arena_release_available();

  // .com.elarian.hera.proto.Cash actual = 3;
  bool has_actual() const;
  private:
  bool _internal_has_actual() const;
  public:
  void clear_actual();
  const ::com::elarian::hera::proto::Cash& actual() const;
  ::com::elarian::hera::proto::Cash* release_actual();
  ::com::elarian::hera::proto::Cash* mutable_actual();
  void set_allocated_actual(::com::elarian::hera::proto::Cash* actual);
  private:
  const ::com::elarian::hera::proto::Cash& _internal_actual() const;
  ::com::elarian::hera::proto::Cash* _internal_mutable_actual();
  public:
  void unsafe_arena_set_allocated_actual(
      ::com::elarian::hera::proto::Cash* actual);
  ::com::elarian::hera::proto::Cash* unsafe_arena_release_actual();

  // int64 sequence_nr = 5;
  void clear_sequence_nr();
  ::PROTOBUF_NAMESPACE_ID::int64 sequence_nr() const;
  void set_sequence_nr(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sequence_nr() const;
  void _internal_set_sequence_nr(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.PaymentBalance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PaymentBalance_PendingEntry_DoNotUse,
      std::string, ::com::elarian::hera::proto::PendingPaymentTransaction,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> pending_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_code_;
  ::com::elarian::hera::proto::Cash* available_;
  ::com::elarian::hera::proto::Cash* actual_;
  ::PROTOBUF_NAMESPACE_ID::int64 sequence_nr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PaymentPurseCounterParty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.PaymentPurseCounterParty) */ {
 public:
  inline PaymentPurseCounterParty() : PaymentPurseCounterParty(nullptr) {}
  virtual ~PaymentPurseCounterParty();

  PaymentPurseCounterParty(const PaymentPurseCounterParty& from);
  PaymentPurseCounterParty(PaymentPurseCounterParty&& from) noexcept
    : PaymentPurseCounterParty() {
    *this = ::std::move(from);
  }

  inline PaymentPurseCounterParty& operator=(const PaymentPurseCounterParty& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentPurseCounterParty& operator=(PaymentPurseCounterParty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentPurseCounterParty& default_instance();

  static inline const PaymentPurseCounterParty* internal_default_instance() {
    return reinterpret_cast<const PaymentPurseCounterParty*>(
               &_PaymentPurseCounterParty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PaymentPurseCounterParty& a, PaymentPurseCounterParty& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentPurseCounterParty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentPurseCounterParty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentPurseCounterParty* New() const final {
    return CreateMaybeMessage<PaymentPurseCounterParty>(nullptr);
  }

  PaymentPurseCounterParty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentPurseCounterParty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentPurseCounterParty& from);
  void MergeFrom(const PaymentPurseCounterParty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentPurseCounterParty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.PaymentPurseCounterParty";
  }
  protected:
  explicit PaymentPurseCounterParty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPurseIdFieldNumber = 1,
  };
  // string purse_id = 1;
  void clear_purse_id();
  const std::string& purse_id() const;
  void set_purse_id(const std::string& value);
  void set_purse_id(std::string&& value);
  void set_purse_id(const char* value);
  void set_purse_id(const char* value, size_t size);
  std::string* mutable_purse_id();
  std::string* release_purse_id();
  void set_allocated_purse_id(std::string* purse_id);
  private:
  const std::string& _internal_purse_id() const;
  void _internal_set_purse_id(const std::string& value);
  std::string* _internal_mutable_purse_id();
  public:

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.PaymentPurseCounterParty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr purse_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PaymentWalletCounterParty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.PaymentWalletCounterParty) */ {
 public:
  inline PaymentWalletCounterParty() : PaymentWalletCounterParty(nullptr) {}
  virtual ~PaymentWalletCounterParty();

  PaymentWalletCounterParty(const PaymentWalletCounterParty& from);
  PaymentWalletCounterParty(PaymentWalletCounterParty&& from) noexcept
    : PaymentWalletCounterParty() {
    *this = ::std::move(from);
  }

  inline PaymentWalletCounterParty& operator=(const PaymentWalletCounterParty& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentWalletCounterParty& operator=(PaymentWalletCounterParty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentWalletCounterParty& default_instance();

  static inline const PaymentWalletCounterParty* internal_default_instance() {
    return reinterpret_cast<const PaymentWalletCounterParty*>(
               &_PaymentWalletCounterParty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PaymentWalletCounterParty& a, PaymentWalletCounterParty& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentWalletCounterParty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentWalletCounterParty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentWalletCounterParty* New() const final {
    return CreateMaybeMessage<PaymentWalletCounterParty>(nullptr);
  }

  PaymentWalletCounterParty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentWalletCounterParty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentWalletCounterParty& from);
  void MergeFrom(const PaymentWalletCounterParty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentWalletCounterParty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.PaymentWalletCounterParty";
  }
  protected:
  explicit PaymentWalletCounterParty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
    kWalletIdFieldNumber = 2,
  };
  // string customer_id = 1;
  void clear_customer_id();
  const std::string& customer_id() const;
  void set_customer_id(const std::string& value);
  void set_customer_id(std::string&& value);
  void set_customer_id(const char* value);
  void set_customer_id(const char* value, size_t size);
  std::string* mutable_customer_id();
  std::string* release_customer_id();
  void set_allocated_customer_id(std::string* customer_id);
  private:
  const std::string& _internal_customer_id() const;
  void _internal_set_customer_id(const std::string& value);
  std::string* _internal_mutable_customer_id();
  public:

  // string wallet_id = 2;
  void clear_wallet_id();
  const std::string& wallet_id() const;
  void set_wallet_id(const std::string& value);
  void set_wallet_id(std::string&& value);
  void set_wallet_id(const char* value);
  void set_wallet_id(const char* value, size_t size);
  std::string* mutable_wallet_id();
  std::string* release_wallet_id();
  void set_allocated_wallet_id(std::string* wallet_id);
  private:
  const std::string& _internal_wallet_id() const;
  void _internal_set_wallet_id(const std::string& value);
  std::string* _internal_mutable_wallet_id();
  public:

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.PaymentWalletCounterParty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PaymentCustomerCounterParty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.PaymentCustomerCounterParty) */ {
 public:
  inline PaymentCustomerCounterParty() : PaymentCustomerCounterParty(nullptr) {}
  virtual ~PaymentCustomerCounterParty();

  PaymentCustomerCounterParty(const PaymentCustomerCounterParty& from);
  PaymentCustomerCounterParty(PaymentCustomerCounterParty&& from) noexcept
    : PaymentCustomerCounterParty() {
    *this = ::std::move(from);
  }

  inline PaymentCustomerCounterParty& operator=(const PaymentCustomerCounterParty& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentCustomerCounterParty& operator=(PaymentCustomerCounterParty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentCustomerCounterParty& default_instance();

  static inline const PaymentCustomerCounterParty* internal_default_instance() {
    return reinterpret_cast<const PaymentCustomerCounterParty*>(
               &_PaymentCustomerCounterParty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PaymentCustomerCounterParty& a, PaymentCustomerCounterParty& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentCustomerCounterParty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentCustomerCounterParty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentCustomerCounterParty* New() const final {
    return CreateMaybeMessage<PaymentCustomerCounterParty>(nullptr);
  }

  PaymentCustomerCounterParty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentCustomerCounterParty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentCustomerCounterParty& from);
  void MergeFrom(const PaymentCustomerCounterParty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentCustomerCounterParty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.PaymentCustomerCounterParty";
  }
  protected:
  explicit PaymentCustomerCounterParty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerNumberFieldNumber = 1,
    kChannelNumberFieldNumber = 2,
  };
  // .com.elarian.hera.proto.CustomerNumber customer_number = 1;
  bool has_customer_number() const;
  private:
  bool _internal_has_customer_number() const;
  public:
  void clear_customer_number();
  const ::com::elarian::hera::proto::CustomerNumber& customer_number() const;
  ::com::elarian::hera::proto::CustomerNumber* release_customer_number();
  ::com::elarian::hera::proto::CustomerNumber* mutable_customer_number();
  void set_allocated_customer_number(::com::elarian::hera::proto::CustomerNumber* customer_number);
  private:
  const ::com::elarian::hera::proto::CustomerNumber& _internal_customer_number() const;
  ::com::elarian::hera::proto::CustomerNumber* _internal_mutable_customer_number();
  public:
  void unsafe_arena_set_allocated_customer_number(
      ::com::elarian::hera::proto::CustomerNumber* customer_number);
  ::com::elarian::hera::proto::CustomerNumber* unsafe_arena_release_customer_number();

  // .com.elarian.hera.proto.PaymentChannelNumber channel_number = 2;
  bool has_channel_number() const;
  private:
  bool _internal_has_channel_number() const;
  public:
  void clear_channel_number();
  const ::com::elarian::hera::proto::PaymentChannelNumber& channel_number() const;
  ::com::elarian::hera::proto::PaymentChannelNumber* release_channel_number();
  ::com::elarian::hera::proto::PaymentChannelNumber* mutable_channel_number();
  void set_allocated_channel_number(::com::elarian::hera::proto::PaymentChannelNumber* channel_number);
  private:
  const ::com::elarian::hera::proto::PaymentChannelNumber& _internal_channel_number() const;
  ::com::elarian::hera::proto::PaymentChannelNumber* _internal_mutable_channel_number();
  public:
  void unsafe_arena_set_allocated_channel_number(
      ::com::elarian::hera::proto::PaymentChannelNumber* channel_number);
  ::com::elarian::hera::proto::PaymentChannelNumber* unsafe_arena_release_channel_number();

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.PaymentCustomerCounterParty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::com::elarian::hera::proto::CustomerNumber* customer_number_;
  ::com::elarian::hera::proto::PaymentChannelNumber* channel_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PaymentChannelCounterParty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.PaymentChannelCounterParty) */ {
 public:
  inline PaymentChannelCounterParty() : PaymentChannelCounterParty(nullptr) {}
  virtual ~PaymentChannelCounterParty();

  PaymentChannelCounterParty(const PaymentChannelCounterParty& from);
  PaymentChannelCounterParty(PaymentChannelCounterParty&& from) noexcept
    : PaymentChannelCounterParty() {
    *this = ::std::move(from);
  }

  inline PaymentChannelCounterParty& operator=(const PaymentChannelCounterParty& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentChannelCounterParty& operator=(PaymentChannelCounterParty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentChannelCounterParty& default_instance();

  static inline const PaymentChannelCounterParty* internal_default_instance() {
    return reinterpret_cast<const PaymentChannelCounterParty*>(
               &_PaymentChannelCounterParty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PaymentChannelCounterParty& a, PaymentChannelCounterParty& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentChannelCounterParty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentChannelCounterParty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentChannelCounterParty* New() const final {
    return CreateMaybeMessage<PaymentChannelCounterParty>(nullptr);
  }

  PaymentChannelCounterParty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentChannelCounterParty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentChannelCounterParty& from);
  void MergeFrom(const PaymentChannelCounterParty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentChannelCounterParty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.PaymentChannelCounterParty";
  }
  protected:
  explicit PaymentChannelCounterParty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 3,
    kDestinationFieldNumber = 4,
    kAccountFieldNumber = 5,
    kChannelFieldNumber = 1,
    kChannelCodeFieldNumber = 2,
  };
  // string source = 3;
  void clear_source();
  const std::string& source() const;
  void set_source(const std::string& value);
  void set_source(std::string&& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  std::string* mutable_source();
  std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string destination = 4;
  void clear_destination();
  const std::string& destination() const;
  void set_destination(const std::string& value);
  void set_destination(std::string&& value);
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  std::string* mutable_destination();
  std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // .google.protobuf.StringValue account = 5;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const PROTOBUF_NAMESPACE_ID::StringValue& account() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_account();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_account();
  void set_allocated_account(PROTOBUF_NAMESPACE_ID::StringValue* account);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_account() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      PROTOBUF_NAMESPACE_ID::StringValue* account);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_account();

  // .com.elarian.hera.proto.PaymentChannel channel = 1;
  void clear_channel();
  ::com::elarian::hera::proto::PaymentChannel channel() const;
  void set_channel(::com::elarian::hera::proto::PaymentChannel value);
  private:
  ::com::elarian::hera::proto::PaymentChannel _internal_channel() const;
  void _internal_set_channel(::com::elarian::hera::proto::PaymentChannel value);
  public:

  // int32 channel_code = 2;
  void clear_channel_code();
  ::PROTOBUF_NAMESPACE_ID::int32 channel_code() const;
  void set_channel_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_channel_code() const;
  void _internal_set_channel_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.PaymentChannelCounterParty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
  PROTOBUF_NAMESPACE_ID::StringValue* account_;
  int channel_;
  ::PROTOBUF_NAMESPACE_ID::int32 channel_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PaymentCounterParty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.PaymentCounterParty) */ {
 public:
  inline PaymentCounterParty() : PaymentCounterParty(nullptr) {}
  virtual ~PaymentCounterParty();

  PaymentCounterParty(const PaymentCounterParty& from);
  PaymentCounterParty(PaymentCounterParty&& from) noexcept
    : PaymentCounterParty() {
    *this = ::std::move(from);
  }

  inline PaymentCounterParty& operator=(const PaymentCounterParty& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentCounterParty& operator=(PaymentCounterParty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentCounterParty& default_instance();

  enum PartyCase {
    kPurse = 1,
    kWallet = 2,
    kCustomer = 3,
    kChannel = 4,
    PARTY_NOT_SET = 0,
  };

  static inline const PaymentCounterParty* internal_default_instance() {
    return reinterpret_cast<const PaymentCounterParty*>(
               &_PaymentCounterParty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PaymentCounterParty& a, PaymentCounterParty& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentCounterParty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentCounterParty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentCounterParty* New() const final {
    return CreateMaybeMessage<PaymentCounterParty>(nullptr);
  }

  PaymentCounterParty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentCounterParty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentCounterParty& from);
  void MergeFrom(const PaymentCounterParty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentCounterParty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.PaymentCounterParty";
  }
  protected:
  explicit PaymentCounterParty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPurseFieldNumber = 1,
    kWalletFieldNumber = 2,
    kCustomerFieldNumber = 3,
    kChannelFieldNumber = 4,
  };
  // .com.elarian.hera.proto.PaymentPurseCounterParty purse = 1;
  bool has_purse() const;
  private:
  bool _internal_has_purse() const;
  public:
  void clear_purse();
  const ::com::elarian::hera::proto::PaymentPurseCounterParty& purse() const;
  ::com::elarian::hera::proto::PaymentPurseCounterParty* release_purse();
  ::com::elarian::hera::proto::PaymentPurseCounterParty* mutable_purse();
  void set_allocated_purse(::com::elarian::hera::proto::PaymentPurseCounterParty* purse);
  private:
  const ::com::elarian::hera::proto::PaymentPurseCounterParty& _internal_purse() const;
  ::com::elarian::hera::proto::PaymentPurseCounterParty* _internal_mutable_purse();
  public:
  void unsafe_arena_set_allocated_purse(
      ::com::elarian::hera::proto::PaymentPurseCounterParty* purse);
  ::com::elarian::hera::proto::PaymentPurseCounterParty* unsafe_arena_release_purse();

  // .com.elarian.hera.proto.PaymentWalletCounterParty wallet = 2;
  bool has_wallet() const;
  private:
  bool _internal_has_wallet() const;
  public:
  void clear_wallet();
  const ::com::elarian::hera::proto::PaymentWalletCounterParty& wallet() const;
  ::com::elarian::hera::proto::PaymentWalletCounterParty* release_wallet();
  ::com::elarian::hera::proto::PaymentWalletCounterParty* mutable_wallet();
  void set_allocated_wallet(::com::elarian::hera::proto::PaymentWalletCounterParty* wallet);
  private:
  const ::com::elarian::hera::proto::PaymentWalletCounterParty& _internal_wallet() const;
  ::com::elarian::hera::proto::PaymentWalletCounterParty* _internal_mutable_wallet();
  public:
  void unsafe_arena_set_allocated_wallet(
      ::com::elarian::hera::proto::PaymentWalletCounterParty* wallet);
  ::com::elarian::hera::proto::PaymentWalletCounterParty* unsafe_arena_release_wallet();

  // .com.elarian.hera.proto.PaymentCustomerCounterParty customer = 3;
  bool has_customer() const;
  private:
  bool _internal_has_customer() const;
  public:
  void clear_customer();
  const ::com::elarian::hera::proto::PaymentCustomerCounterParty& customer() const;
  ::com::elarian::hera::proto::PaymentCustomerCounterParty* release_customer();
  ::com::elarian::hera::proto::PaymentCustomerCounterParty* mutable_customer();
  void set_allocated_customer(::com::elarian::hera::proto::PaymentCustomerCounterParty* customer);
  private:
  const ::com::elarian::hera::proto::PaymentCustomerCounterParty& _internal_customer() const;
  ::com::elarian::hera::proto::PaymentCustomerCounterParty* _internal_mutable_customer();
  public:
  void unsafe_arena_set_allocated_customer(
      ::com::elarian::hera::proto::PaymentCustomerCounterParty* customer);
  ::com::elarian::hera::proto::PaymentCustomerCounterParty* unsafe_arena_release_customer();

  // .com.elarian.hera.proto.PaymentChannelCounterParty channel = 4;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  const ::com::elarian::hera::proto::PaymentChannelCounterParty& channel() const;
  ::com::elarian::hera::proto::PaymentChannelCounterParty* release_channel();
  ::com::elarian::hera::proto::PaymentChannelCounterParty* mutable_channel();
  void set_allocated_channel(::com::elarian::hera::proto::PaymentChannelCounterParty* channel);
  private:
  const ::com::elarian::hera::proto::PaymentChannelCounterParty& _internal_channel() const;
  ::com::elarian::hera::proto::PaymentChannelCounterParty* _internal_mutable_channel();
  public:
  void unsafe_arena_set_allocated_channel(
      ::com::elarian::hera::proto::PaymentChannelCounterParty* channel);
  ::com::elarian::hera::proto::PaymentChannelCounterParty* unsafe_arena_release_channel();

  void clear_party();
  PartyCase party_case() const;
  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.PaymentCounterParty)
 private:
  class _Internal;
  void set_has_purse();
  void set_has_wallet();
  void set_has_customer();
  void set_has_channel();

  inline bool has_party() const;
  inline void clear_has_party();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PartyUnion {
    PartyUnion() {}
    ::com::elarian::hera::proto::PaymentPurseCounterParty* purse_;
    ::com::elarian::hera::proto::PaymentWalletCounterParty* wallet_;
    ::com::elarian::hera::proto::PaymentCustomerCounterParty* customer_;
    ::com::elarian::hera::proto::PaymentChannelCounterParty* channel_;
  } party_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_payment_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PaymentTransaction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.PaymentTransaction) */ {
 public:
  inline PaymentTransaction() : PaymentTransaction(nullptr) {}
  virtual ~PaymentTransaction();

  PaymentTransaction(const PaymentTransaction& from);
  PaymentTransaction(PaymentTransaction&& from) noexcept
    : PaymentTransaction() {
    *this = ::std::move(from);
  }

  inline PaymentTransaction& operator=(const PaymentTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentTransaction& operator=(PaymentTransaction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentTransaction& default_instance();

  static inline const PaymentTransaction* internal_default_instance() {
    return reinterpret_cast<const PaymentTransaction*>(
               &_PaymentTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PaymentTransaction& a, PaymentTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentTransaction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentTransaction* New() const final {
    return CreateMaybeMessage<PaymentTransaction>(nullptr);
  }

  PaymentTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentTransaction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentTransaction& from);
  void MergeFrom(const PaymentTransaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentTransaction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.PaymentTransaction";
  }
  protected:
  explicit PaymentTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_payment_5fmodel_2eproto);
    return ::descriptor_table_payment_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kDebitPartyFieldNumber = 4,
    kCreditPartyFieldNumber = 5,
    kValueFieldNumber = 6,
    kCreatedAtFieldNumber = 8,
    kUpdatedAtFieldNumber = 9,
    kProviderTransactionIdFieldNumber = 10,
    kStatusFieldNumber = 7,
  };
  // string transaction_id = 1;
  void clear_transaction_id();
  const std::string& transaction_id() const;
  void set_transaction_id(const std::string& value);
  void set_transaction_id(std::string&& value);
  void set_transaction_id(const char* value);
  void set_transaction_id(const char* value, size_t size);
  std::string* mutable_transaction_id();
  std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // .google.protobuf.StringValue app_id = 2;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  const PROTOBUF_NAMESPACE_ID::StringValue& app_id() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_app_id();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_app_id();
  void set_allocated_app_id(PROTOBUF_NAMESPACE_ID::StringValue* app_id);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_app_id() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_app_id();
  public:
  void unsafe_arena_set_allocated_app_id(
      PROTOBUF_NAMESPACE_ID::StringValue* app_id);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_app_id();

  // .com.elarian.hera.proto.PaymentCounterParty debit_party = 4;
  bool has_debit_party() const;
  private:
  bool _internal_has_debit_party() const;
  public:
  void clear_debit_party();
  const ::com::elarian::hera::proto::PaymentCounterParty& debit_party() const;
  ::com::elarian::hera::proto::PaymentCounterParty* release_debit_party();
  ::com::elarian::hera::proto::PaymentCounterParty* mutable_debit_party();
  void set_allocated_debit_party(::com::elarian::hera::proto::PaymentCounterParty* debit_party);
  private:
  const ::com::elarian::hera::proto::PaymentCounterParty& _internal_debit_party() const;
  ::com::elarian::hera::proto::PaymentCounterParty* _internal_mutable_debit_party();
  public:
  void unsafe_arena_set_allocated_debit_party(
      ::com::elarian::hera::proto::PaymentCounterParty* debit_party);
  ::com::elarian::hera::proto::PaymentCounterParty* unsafe_arena_release_debit_party();

  // .com.elarian.hera.proto.PaymentCounterParty credit_party = 5;
  bool has_credit_party() const;
  private:
  bool _internal_has_credit_party() const;
  public:
  void clear_credit_party();
  const ::com::elarian::hera::proto::PaymentCounterParty& credit_party() const;
  ::com::elarian::hera::proto::PaymentCounterParty* release_credit_party();
  ::com::elarian::hera::proto::PaymentCounterParty* mutable_credit_party();
  void set_allocated_credit_party(::com::elarian::hera::proto::PaymentCounterParty* credit_party);
  private:
  const ::com::elarian::hera::proto::PaymentCounterParty& _internal_credit_party() const;
  ::com::elarian::hera::proto::PaymentCounterParty* _internal_mutable_credit_party();
  public:
  void unsafe_arena_set_allocated_credit_party(
      ::com::elarian::hera::proto::PaymentCounterParty* credit_party);
  ::com::elarian::hera::proto::PaymentCounterParty* unsafe_arena_release_credit_party();

  // .com.elarian.hera.proto.Cash value = 6;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::com::elarian::hera::proto::Cash& value() const;
  ::com::elarian::hera::proto::Cash* release_value();
  ::com::elarian::hera::proto::Cash* mutable_value();
  void set_allocated_value(::com::elarian::hera::proto::Cash* value);
  private:
  const ::com::elarian::hera::proto::Cash& _internal_value() const;
  ::com::elarian::hera::proto::Cash* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::com::elarian::hera::proto::Cash* value);
  ::com::elarian::hera::proto::Cash* unsafe_arena_release_value();

  // .google.protobuf.Timestamp created_at = 8;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 9;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // .google.protobuf.StringValue provider_transaction_id = 10;
  bool has_provider_transaction_id() const;
  private:
  bool _internal_has_provider_transaction_id() const;
  public:
  void clear_provider_transaction_id();
  const PROTOBUF_NAMESPACE_ID::StringValue& provider_transaction_id() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_provider_transaction_id();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_provider_transaction_id();
  void set_allocated_provider_transaction_id(PROTOBUF_NAMESPACE_ID::StringValue* provider_transaction_id);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_provider_transaction_id() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_provider_transaction_id();
  public:
  void unsafe_arena_set_allocated_provider_transaction_id(
      PROTOBUF_NAMESPACE_ID::StringValue* provider_transaction_id);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_provider_transaction_id();

  // .com.elarian.hera.proto.PaymentStatus status = 7;
  void clear_status();
  ::com::elarian::hera::proto::PaymentStatus status() const;
  void set_status(::com::elarian::hera::proto::PaymentStatus value);
  private:
  ::com::elarian::hera::proto::PaymentStatus _internal_status() const;
  void _internal_set_status(::com::elarian::hera::proto::PaymentStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.PaymentTransaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  PROTOBUF_NAMESPACE_ID::StringValue* app_id_;
  ::com::elarian::hera::proto::PaymentCounterParty* debit_party_;
  ::com::elarian::hera::proto::PaymentCounterParty* credit_party_;
  ::com::elarian::hera::proto::Cash* value_;
  PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
  PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
  PROTOBUF_NAMESPACE_ID::StringValue* provider_transaction_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_payment_5fmodel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PaymentChannelNumber

// .com.elarian.hera.proto.PaymentChannel channel = 1;
inline void PaymentChannelNumber::clear_channel() {
  channel_ = 0;
}
inline ::com::elarian::hera::proto::PaymentChannel PaymentChannelNumber::_internal_channel() const {
  return static_cast< ::com::elarian::hera::proto::PaymentChannel >(channel_);
}
inline ::com::elarian::hera::proto::PaymentChannel PaymentChannelNumber::channel() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentChannelNumber.channel)
  return _internal_channel();
}
inline void PaymentChannelNumber::_internal_set_channel(::com::elarian::hera::proto::PaymentChannel value) {
  
  channel_ = value;
}
inline void PaymentChannelNumber::set_channel(::com::elarian::hera::proto::PaymentChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentChannelNumber.channel)
}

// string number = 2;
inline void PaymentChannelNumber::clear_number() {
  number_.ClearToEmpty();
}
inline const std::string& PaymentChannelNumber::number() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentChannelNumber.number)
  return _internal_number();
}
inline void PaymentChannelNumber::set_number(const std::string& value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentChannelNumber.number)
}
inline std::string* PaymentChannelNumber::mutable_number() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentChannelNumber.number)
  return _internal_mutable_number();
}
inline const std::string& PaymentChannelNumber::_internal_number() const {
  return number_.Get();
}
inline void PaymentChannelNumber::_internal_set_number(const std::string& value) {
  
  number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PaymentChannelNumber::set_number(std::string&& value) {
  
  number_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.PaymentChannelNumber.number)
}
inline void PaymentChannelNumber::set_number(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.PaymentChannelNumber.number)
}
inline void PaymentChannelNumber::set_number(const char* value,
    size_t size) {
  
  number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.PaymentChannelNumber.number)
}
inline std::string* PaymentChannelNumber::_internal_mutable_number() {
  
  return number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PaymentChannelNumber::release_number() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentChannelNumber.number)
  return number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PaymentChannelNumber::set_allocated_number(std::string* number) {
  if (number != nullptr) {
    
  } else {
    
  }
  number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), number,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentChannelNumber.number)
}

// -------------------------------------------------------------------

// PendingPaymentTransaction

// .google.protobuf.Timestamp created_at = 1;
inline bool PendingPaymentTransaction::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool PendingPaymentTransaction::has_created_at() const {
  return _internal_has_created_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PendingPaymentTransaction::_internal_created_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PendingPaymentTransaction::created_at() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PendingPaymentTransaction.created_at)
  return _internal_created_at();
}
inline void PendingPaymentTransaction::unsafe_arena_set_allocated_created_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PendingPaymentTransaction.created_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PendingPaymentTransaction::release_created_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PendingPaymentTransaction::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PendingPaymentTransaction.created_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PendingPaymentTransaction::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    created_at_ = p;
  }
  return created_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PendingPaymentTransaction::mutable_created_at() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PendingPaymentTransaction.created_at)
  return _internal_mutable_created_at();
}
inline void PendingPaymentTransaction::set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at)->GetArena();
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PendingPaymentTransaction.created_at)
}

// .com.elarian.hera.proto.Cash value = 2;
inline bool PendingPaymentTransaction::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool PendingPaymentTransaction::has_value() const {
  return _internal_has_value();
}
inline const ::com::elarian::hera::proto::Cash& PendingPaymentTransaction::_internal_value() const {
  const ::com::elarian::hera::proto::Cash* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::Cash&>(
      ::com::elarian::hera::proto::_Cash_default_instance_);
}
inline const ::com::elarian::hera::proto::Cash& PendingPaymentTransaction::value() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PendingPaymentTransaction.value)
  return _internal_value();
}
inline void PendingPaymentTransaction::unsafe_arena_set_allocated_value(
    ::com::elarian::hera::proto::Cash* value) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PendingPaymentTransaction.value)
}
inline ::com::elarian::hera::proto::Cash* PendingPaymentTransaction::release_value() {
  
  ::com::elarian::hera::proto::Cash* temp = value_;
  value_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PendingPaymentTransaction::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PendingPaymentTransaction.value)
  
  ::com::elarian::hera::proto::Cash* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PendingPaymentTransaction::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::Cash>(GetArena());
    value_ = p;
  }
  return value_;
}
inline ::com::elarian::hera::proto::Cash* PendingPaymentTransaction::mutable_value() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PendingPaymentTransaction.value)
  return _internal_mutable_value();
}
inline void PendingPaymentTransaction::set_allocated_value(::com::elarian::hera::proto::Cash* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PendingPaymentTransaction.value)
}

// .com.elarian.hera.proto.Cash converted = 3;
inline bool PendingPaymentTransaction::_internal_has_converted() const {
  return this != internal_default_instance() && converted_ != nullptr;
}
inline bool PendingPaymentTransaction::has_converted() const {
  return _internal_has_converted();
}
inline const ::com::elarian::hera::proto::Cash& PendingPaymentTransaction::_internal_converted() const {
  const ::com::elarian::hera::proto::Cash* p = converted_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::Cash&>(
      ::com::elarian::hera::proto::_Cash_default_instance_);
}
inline const ::com::elarian::hera::proto::Cash& PendingPaymentTransaction::converted() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PendingPaymentTransaction.converted)
  return _internal_converted();
}
inline void PendingPaymentTransaction::unsafe_arena_set_allocated_converted(
    ::com::elarian::hera::proto::Cash* converted) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(converted_);
  }
  converted_ = converted;
  if (converted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PendingPaymentTransaction.converted)
}
inline ::com::elarian::hera::proto::Cash* PendingPaymentTransaction::release_converted() {
  
  ::com::elarian::hera::proto::Cash* temp = converted_;
  converted_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PendingPaymentTransaction::unsafe_arena_release_converted() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PendingPaymentTransaction.converted)
  
  ::com::elarian::hera::proto::Cash* temp = converted_;
  converted_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PendingPaymentTransaction::_internal_mutable_converted() {
  
  if (converted_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::Cash>(GetArena());
    converted_ = p;
  }
  return converted_;
}
inline ::com::elarian::hera::proto::Cash* PendingPaymentTransaction::mutable_converted() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PendingPaymentTransaction.converted)
  return _internal_mutable_converted();
}
inline void PendingPaymentTransaction::set_allocated_converted(::com::elarian::hera::proto::Cash* converted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(converted_);
  }
  if (converted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(converted)->GetArena();
    if (message_arena != submessage_arena) {
      converted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, converted, submessage_arena);
    }
    
  } else {
    
  }
  converted_ = converted;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PendingPaymentTransaction.converted)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PaymentBalance

// string currency_code = 1;
inline void PaymentBalance::clear_currency_code() {
  currency_code_.ClearToEmpty();
}
inline const std::string& PaymentBalance::currency_code() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentBalance.currency_code)
  return _internal_currency_code();
}
inline void PaymentBalance::set_currency_code(const std::string& value) {
  _internal_set_currency_code(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentBalance.currency_code)
}
inline std::string* PaymentBalance::mutable_currency_code() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentBalance.currency_code)
  return _internal_mutable_currency_code();
}
inline const std::string& PaymentBalance::_internal_currency_code() const {
  return currency_code_.Get();
}
inline void PaymentBalance::_internal_set_currency_code(const std::string& value) {
  
  currency_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PaymentBalance::set_currency_code(std::string&& value) {
  
  currency_code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.PaymentBalance.currency_code)
}
inline void PaymentBalance::set_currency_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  currency_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.PaymentBalance.currency_code)
}
inline void PaymentBalance::set_currency_code(const char* value,
    size_t size) {
  
  currency_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.PaymentBalance.currency_code)
}
inline std::string* PaymentBalance::_internal_mutable_currency_code() {
  
  return currency_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PaymentBalance::release_currency_code() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentBalance.currency_code)
  return currency_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PaymentBalance::set_allocated_currency_code(std::string* currency_code) {
  if (currency_code != nullptr) {
    
  } else {
    
  }
  currency_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), currency_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentBalance.currency_code)
}

// .com.elarian.hera.proto.Cash available = 2;
inline bool PaymentBalance::_internal_has_available() const {
  return this != internal_default_instance() && available_ != nullptr;
}
inline bool PaymentBalance::has_available() const {
  return _internal_has_available();
}
inline const ::com::elarian::hera::proto::Cash& PaymentBalance::_internal_available() const {
  const ::com::elarian::hera::proto::Cash* p = available_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::Cash&>(
      ::com::elarian::hera::proto::_Cash_default_instance_);
}
inline const ::com::elarian::hera::proto::Cash& PaymentBalance::available() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentBalance.available)
  return _internal_available();
}
inline void PaymentBalance::unsafe_arena_set_allocated_available(
    ::com::elarian::hera::proto::Cash* available) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(available_);
  }
  available_ = available;
  if (available) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentBalance.available)
}
inline ::com::elarian::hera::proto::Cash* PaymentBalance::release_available() {
  
  ::com::elarian::hera::proto::Cash* temp = available_;
  available_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PaymentBalance::unsafe_arena_release_available() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentBalance.available)
  
  ::com::elarian::hera::proto::Cash* temp = available_;
  available_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PaymentBalance::_internal_mutable_available() {
  
  if (available_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::Cash>(GetArena());
    available_ = p;
  }
  return available_;
}
inline ::com::elarian::hera::proto::Cash* PaymentBalance::mutable_available() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentBalance.available)
  return _internal_mutable_available();
}
inline void PaymentBalance::set_allocated_available(::com::elarian::hera::proto::Cash* available) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(available_);
  }
  if (available) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(available)->GetArena();
    if (message_arena != submessage_arena) {
      available = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, available, submessage_arena);
    }
    
  } else {
    
  }
  available_ = available;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentBalance.available)
}

// .com.elarian.hera.proto.Cash actual = 3;
inline bool PaymentBalance::_internal_has_actual() const {
  return this != internal_default_instance() && actual_ != nullptr;
}
inline bool PaymentBalance::has_actual() const {
  return _internal_has_actual();
}
inline const ::com::elarian::hera::proto::Cash& PaymentBalance::_internal_actual() const {
  const ::com::elarian::hera::proto::Cash* p = actual_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::Cash&>(
      ::com::elarian::hera::proto::_Cash_default_instance_);
}
inline const ::com::elarian::hera::proto::Cash& PaymentBalance::actual() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentBalance.actual)
  return _internal_actual();
}
inline void PaymentBalance::unsafe_arena_set_allocated_actual(
    ::com::elarian::hera::proto::Cash* actual) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actual_);
  }
  actual_ = actual;
  if (actual) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentBalance.actual)
}
inline ::com::elarian::hera::proto::Cash* PaymentBalance::release_actual() {
  
  ::com::elarian::hera::proto::Cash* temp = actual_;
  actual_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PaymentBalance::unsafe_arena_release_actual() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentBalance.actual)
  
  ::com::elarian::hera::proto::Cash* temp = actual_;
  actual_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PaymentBalance::_internal_mutable_actual() {
  
  if (actual_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::Cash>(GetArena());
    actual_ = p;
  }
  return actual_;
}
inline ::com::elarian::hera::proto::Cash* PaymentBalance::mutable_actual() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentBalance.actual)
  return _internal_mutable_actual();
}
inline void PaymentBalance::set_allocated_actual(::com::elarian::hera::proto::Cash* actual) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(actual_);
  }
  if (actual) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(actual)->GetArena();
    if (message_arena != submessage_arena) {
      actual = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actual, submessage_arena);
    }
    
  } else {
    
  }
  actual_ = actual;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentBalance.actual)
}

// map<string, .com.elarian.hera.proto.PendingPaymentTransaction> pending = 4;
inline int PaymentBalance::_internal_pending_size() const {
  return pending_.size();
}
inline int PaymentBalance::pending_size() const {
  return _internal_pending_size();
}
inline void PaymentBalance::clear_pending() {
  pending_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::elarian::hera::proto::PendingPaymentTransaction >&
PaymentBalance::_internal_pending() const {
  return pending_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::elarian::hera::proto::PendingPaymentTransaction >&
PaymentBalance::pending() const {
  // @@protoc_insertion_point(field_map:com.elarian.hera.proto.PaymentBalance.pending)
  return _internal_pending();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::elarian::hera::proto::PendingPaymentTransaction >*
PaymentBalance::_internal_mutable_pending() {
  return pending_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::elarian::hera::proto::PendingPaymentTransaction >*
PaymentBalance::mutable_pending() {
  // @@protoc_insertion_point(field_mutable_map:com.elarian.hera.proto.PaymentBalance.pending)
  return _internal_mutable_pending();
}

// int64 sequence_nr = 5;
inline void PaymentBalance::clear_sequence_nr() {
  sequence_nr_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PaymentBalance::_internal_sequence_nr() const {
  return sequence_nr_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PaymentBalance::sequence_nr() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentBalance.sequence_nr)
  return _internal_sequence_nr();
}
inline void PaymentBalance::_internal_set_sequence_nr(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sequence_nr_ = value;
}
inline void PaymentBalance::set_sequence_nr(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sequence_nr(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentBalance.sequence_nr)
}

// -------------------------------------------------------------------

// PaymentPurseCounterParty

// string purse_id = 1;
inline void PaymentPurseCounterParty::clear_purse_id() {
  purse_id_.ClearToEmpty();
}
inline const std::string& PaymentPurseCounterParty::purse_id() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentPurseCounterParty.purse_id)
  return _internal_purse_id();
}
inline void PaymentPurseCounterParty::set_purse_id(const std::string& value) {
  _internal_set_purse_id(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentPurseCounterParty.purse_id)
}
inline std::string* PaymentPurseCounterParty::mutable_purse_id() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentPurseCounterParty.purse_id)
  return _internal_mutable_purse_id();
}
inline const std::string& PaymentPurseCounterParty::_internal_purse_id() const {
  return purse_id_.Get();
}
inline void PaymentPurseCounterParty::_internal_set_purse_id(const std::string& value) {
  
  purse_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PaymentPurseCounterParty::set_purse_id(std::string&& value) {
  
  purse_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.PaymentPurseCounterParty.purse_id)
}
inline void PaymentPurseCounterParty::set_purse_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  purse_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.PaymentPurseCounterParty.purse_id)
}
inline void PaymentPurseCounterParty::set_purse_id(const char* value,
    size_t size) {
  
  purse_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.PaymentPurseCounterParty.purse_id)
}
inline std::string* PaymentPurseCounterParty::_internal_mutable_purse_id() {
  
  return purse_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PaymentPurseCounterParty::release_purse_id() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentPurseCounterParty.purse_id)
  return purse_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PaymentPurseCounterParty::set_allocated_purse_id(std::string* purse_id) {
  if (purse_id != nullptr) {
    
  } else {
    
  }
  purse_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), purse_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentPurseCounterParty.purse_id)
}

// -------------------------------------------------------------------

// PaymentWalletCounterParty

// string customer_id = 1;
inline void PaymentWalletCounterParty::clear_customer_id() {
  customer_id_.ClearToEmpty();
}
inline const std::string& PaymentWalletCounterParty::customer_id() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentWalletCounterParty.customer_id)
  return _internal_customer_id();
}
inline void PaymentWalletCounterParty::set_customer_id(const std::string& value) {
  _internal_set_customer_id(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentWalletCounterParty.customer_id)
}
inline std::string* PaymentWalletCounterParty::mutable_customer_id() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentWalletCounterParty.customer_id)
  return _internal_mutable_customer_id();
}
inline const std::string& PaymentWalletCounterParty::_internal_customer_id() const {
  return customer_id_.Get();
}
inline void PaymentWalletCounterParty::_internal_set_customer_id(const std::string& value) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PaymentWalletCounterParty::set_customer_id(std::string&& value) {
  
  customer_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.PaymentWalletCounterParty.customer_id)
}
inline void PaymentWalletCounterParty::set_customer_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.PaymentWalletCounterParty.customer_id)
}
inline void PaymentWalletCounterParty::set_customer_id(const char* value,
    size_t size) {
  
  customer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.PaymentWalletCounterParty.customer_id)
}
inline std::string* PaymentWalletCounterParty::_internal_mutable_customer_id() {
  
  return customer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PaymentWalletCounterParty::release_customer_id() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentWalletCounterParty.customer_id)
  return customer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PaymentWalletCounterParty::set_allocated_customer_id(std::string* customer_id) {
  if (customer_id != nullptr) {
    
  } else {
    
  }
  customer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customer_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentWalletCounterParty.customer_id)
}

// string wallet_id = 2;
inline void PaymentWalletCounterParty::clear_wallet_id() {
  wallet_id_.ClearToEmpty();
}
inline const std::string& PaymentWalletCounterParty::wallet_id() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentWalletCounterParty.wallet_id)
  return _internal_wallet_id();
}
inline void PaymentWalletCounterParty::set_wallet_id(const std::string& value) {
  _internal_set_wallet_id(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentWalletCounterParty.wallet_id)
}
inline std::string* PaymentWalletCounterParty::mutable_wallet_id() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentWalletCounterParty.wallet_id)
  return _internal_mutable_wallet_id();
}
inline const std::string& PaymentWalletCounterParty::_internal_wallet_id() const {
  return wallet_id_.Get();
}
inline void PaymentWalletCounterParty::_internal_set_wallet_id(const std::string& value) {
  
  wallet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PaymentWalletCounterParty::set_wallet_id(std::string&& value) {
  
  wallet_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.PaymentWalletCounterParty.wallet_id)
}
inline void PaymentWalletCounterParty::set_wallet_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  wallet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.PaymentWalletCounterParty.wallet_id)
}
inline void PaymentWalletCounterParty::set_wallet_id(const char* value,
    size_t size) {
  
  wallet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.PaymentWalletCounterParty.wallet_id)
}
inline std::string* PaymentWalletCounterParty::_internal_mutable_wallet_id() {
  
  return wallet_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PaymentWalletCounterParty::release_wallet_id() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentWalletCounterParty.wallet_id)
  return wallet_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PaymentWalletCounterParty::set_allocated_wallet_id(std::string* wallet_id) {
  if (wallet_id != nullptr) {
    
  } else {
    
  }
  wallet_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), wallet_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentWalletCounterParty.wallet_id)
}

// -------------------------------------------------------------------

// PaymentCustomerCounterParty

// .com.elarian.hera.proto.CustomerNumber customer_number = 1;
inline bool PaymentCustomerCounterParty::_internal_has_customer_number() const {
  return this != internal_default_instance() && customer_number_ != nullptr;
}
inline bool PaymentCustomerCounterParty::has_customer_number() const {
  return _internal_has_customer_number();
}
inline const ::com::elarian::hera::proto::CustomerNumber& PaymentCustomerCounterParty::_internal_customer_number() const {
  const ::com::elarian::hera::proto::CustomerNumber* p = customer_number_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::CustomerNumber&>(
      ::com::elarian::hera::proto::_CustomerNumber_default_instance_);
}
inline const ::com::elarian::hera::proto::CustomerNumber& PaymentCustomerCounterParty::customer_number() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentCustomerCounterParty.customer_number)
  return _internal_customer_number();
}
inline void PaymentCustomerCounterParty::unsafe_arena_set_allocated_customer_number(
    ::com::elarian::hera::proto::CustomerNumber* customer_number) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_number_);
  }
  customer_number_ = customer_number;
  if (customer_number) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentCustomerCounterParty.customer_number)
}
inline ::com::elarian::hera::proto::CustomerNumber* PaymentCustomerCounterParty::release_customer_number() {
  
  ::com::elarian::hera::proto::CustomerNumber* temp = customer_number_;
  customer_number_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::CustomerNumber* PaymentCustomerCounterParty::unsafe_arena_release_customer_number() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentCustomerCounterParty.customer_number)
  
  ::com::elarian::hera::proto::CustomerNumber* temp = customer_number_;
  customer_number_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::CustomerNumber* PaymentCustomerCounterParty::_internal_mutable_customer_number() {
  
  if (customer_number_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::CustomerNumber>(GetArena());
    customer_number_ = p;
  }
  return customer_number_;
}
inline ::com::elarian::hera::proto::CustomerNumber* PaymentCustomerCounterParty::mutable_customer_number() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentCustomerCounterParty.customer_number)
  return _internal_mutable_customer_number();
}
inline void PaymentCustomerCounterParty::set_allocated_customer_number(::com::elarian::hera::proto::CustomerNumber* customer_number) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_number_);
  }
  if (customer_number) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customer_number)->GetArena();
    if (message_arena != submessage_arena) {
      customer_number = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customer_number, submessage_arena);
    }
    
  } else {
    
  }
  customer_number_ = customer_number;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentCustomerCounterParty.customer_number)
}

// .com.elarian.hera.proto.PaymentChannelNumber channel_number = 2;
inline bool PaymentCustomerCounterParty::_internal_has_channel_number() const {
  return this != internal_default_instance() && channel_number_ != nullptr;
}
inline bool PaymentCustomerCounterParty::has_channel_number() const {
  return _internal_has_channel_number();
}
inline void PaymentCustomerCounterParty::clear_channel_number() {
  if (GetArena() == nullptr && channel_number_ != nullptr) {
    delete channel_number_;
  }
  channel_number_ = nullptr;
}
inline const ::com::elarian::hera::proto::PaymentChannelNumber& PaymentCustomerCounterParty::_internal_channel_number() const {
  const ::com::elarian::hera::proto::PaymentChannelNumber* p = channel_number_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::PaymentChannelNumber&>(
      ::com::elarian::hera::proto::_PaymentChannelNumber_default_instance_);
}
inline const ::com::elarian::hera::proto::PaymentChannelNumber& PaymentCustomerCounterParty::channel_number() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentCustomerCounterParty.channel_number)
  return _internal_channel_number();
}
inline void PaymentCustomerCounterParty::unsafe_arena_set_allocated_channel_number(
    ::com::elarian::hera::proto::PaymentChannelNumber* channel_number) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(channel_number_);
  }
  channel_number_ = channel_number;
  if (channel_number) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentCustomerCounterParty.channel_number)
}
inline ::com::elarian::hera::proto::PaymentChannelNumber* PaymentCustomerCounterParty::release_channel_number() {
  
  ::com::elarian::hera::proto::PaymentChannelNumber* temp = channel_number_;
  channel_number_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::PaymentChannelNumber* PaymentCustomerCounterParty::unsafe_arena_release_channel_number() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentCustomerCounterParty.channel_number)
  
  ::com::elarian::hera::proto::PaymentChannelNumber* temp = channel_number_;
  channel_number_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::PaymentChannelNumber* PaymentCustomerCounterParty::_internal_mutable_channel_number() {
  
  if (channel_number_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::PaymentChannelNumber>(GetArena());
    channel_number_ = p;
  }
  return channel_number_;
}
inline ::com::elarian::hera::proto::PaymentChannelNumber* PaymentCustomerCounterParty::mutable_channel_number() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentCustomerCounterParty.channel_number)
  return _internal_mutable_channel_number();
}
inline void PaymentCustomerCounterParty::set_allocated_channel_number(::com::elarian::hera::proto::PaymentChannelNumber* channel_number) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete channel_number_;
  }
  if (channel_number) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(channel_number);
    if (message_arena != submessage_arena) {
      channel_number = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, channel_number, submessage_arena);
    }
    
  } else {
    
  }
  channel_number_ = channel_number;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentCustomerCounterParty.channel_number)
}

// -------------------------------------------------------------------

// PaymentChannelCounterParty

// .com.elarian.hera.proto.PaymentChannel channel = 1;
inline void PaymentChannelCounterParty::clear_channel() {
  channel_ = 0;
}
inline ::com::elarian::hera::proto::PaymentChannel PaymentChannelCounterParty::_internal_channel() const {
  return static_cast< ::com::elarian::hera::proto::PaymentChannel >(channel_);
}
inline ::com::elarian::hera::proto::PaymentChannel PaymentChannelCounterParty::channel() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentChannelCounterParty.channel)
  return _internal_channel();
}
inline void PaymentChannelCounterParty::_internal_set_channel(::com::elarian::hera::proto::PaymentChannel value) {
  
  channel_ = value;
}
inline void PaymentChannelCounterParty::set_channel(::com::elarian::hera::proto::PaymentChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentChannelCounterParty.channel)
}

// int32 channel_code = 2;
inline void PaymentChannelCounterParty::clear_channel_code() {
  channel_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaymentChannelCounterParty::_internal_channel_code() const {
  return channel_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PaymentChannelCounterParty::channel_code() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentChannelCounterParty.channel_code)
  return _internal_channel_code();
}
inline void PaymentChannelCounterParty::_internal_set_channel_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  channel_code_ = value;
}
inline void PaymentChannelCounterParty::set_channel_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_channel_code(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentChannelCounterParty.channel_code)
}

// string source = 3;
inline void PaymentChannelCounterParty::clear_source() {
  source_.ClearToEmpty();
}
inline const std::string& PaymentChannelCounterParty::source() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentChannelCounterParty.source)
  return _internal_source();
}
inline void PaymentChannelCounterParty::set_source(const std::string& value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentChannelCounterParty.source)
}
inline std::string* PaymentChannelCounterParty::mutable_source() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentChannelCounterParty.source)
  return _internal_mutable_source();
}
inline const std::string& PaymentChannelCounterParty::_internal_source() const {
  return source_.Get();
}
inline void PaymentChannelCounterParty::_internal_set_source(const std::string& value) {
  
  source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PaymentChannelCounterParty::set_source(std::string&& value) {
  
  source_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.PaymentChannelCounterParty.source)
}
inline void PaymentChannelCounterParty::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.PaymentChannelCounterParty.source)
}
inline void PaymentChannelCounterParty::set_source(const char* value,
    size_t size) {
  
  source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.PaymentChannelCounterParty.source)
}
inline std::string* PaymentChannelCounterParty::_internal_mutable_source() {
  
  return source_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PaymentChannelCounterParty::release_source() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentChannelCounterParty.source)
  return source_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PaymentChannelCounterParty::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  source_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentChannelCounterParty.source)
}

// string destination = 4;
inline void PaymentChannelCounterParty::clear_destination() {
  destination_.ClearToEmpty();
}
inline const std::string& PaymentChannelCounterParty::destination() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentChannelCounterParty.destination)
  return _internal_destination();
}
inline void PaymentChannelCounterParty::set_destination(const std::string& value) {
  _internal_set_destination(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentChannelCounterParty.destination)
}
inline std::string* PaymentChannelCounterParty::mutable_destination() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentChannelCounterParty.destination)
  return _internal_mutable_destination();
}
inline const std::string& PaymentChannelCounterParty::_internal_destination() const {
  return destination_.Get();
}
inline void PaymentChannelCounterParty::_internal_set_destination(const std::string& value) {
  
  destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PaymentChannelCounterParty::set_destination(std::string&& value) {
  
  destination_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.PaymentChannelCounterParty.destination)
}
inline void PaymentChannelCounterParty::set_destination(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.PaymentChannelCounterParty.destination)
}
inline void PaymentChannelCounterParty::set_destination(const char* value,
    size_t size) {
  
  destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.PaymentChannelCounterParty.destination)
}
inline std::string* PaymentChannelCounterParty::_internal_mutable_destination() {
  
  return destination_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PaymentChannelCounterParty::release_destination() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentChannelCounterParty.destination)
  return destination_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PaymentChannelCounterParty::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  destination_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentChannelCounterParty.destination)
}

// .google.protobuf.StringValue account = 5;
inline bool PaymentChannelCounterParty::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool PaymentChannelCounterParty::has_account() const {
  return _internal_has_account();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& PaymentChannelCounterParty::_internal_account() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& PaymentChannelCounterParty::account() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentChannelCounterParty.account)
  return _internal_account();
}
inline void PaymentChannelCounterParty::unsafe_arena_set_allocated_account(
    PROTOBUF_NAMESPACE_ID::StringValue* account) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentChannelCounterParty.account)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentChannelCounterParty::release_account() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = account_;
  account_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentChannelCounterParty::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentChannelCounterParty.account)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = account_;
  account_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentChannelCounterParty::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    account_ = p;
  }
  return account_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentChannelCounterParty::mutable_account() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentChannelCounterParty.account)
  return _internal_mutable_account();
}
inline void PaymentChannelCounterParty::set_allocated_account(PROTOBUF_NAMESPACE_ID::StringValue* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account)->GetArena();
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentChannelCounterParty.account)
}

// -------------------------------------------------------------------

// PaymentCounterParty

// .com.elarian.hera.proto.PaymentPurseCounterParty purse = 1;
inline bool PaymentCounterParty::_internal_has_purse() const {
  return party_case() == kPurse;
}
inline bool PaymentCounterParty::has_purse() const {
  return _internal_has_purse();
}
inline void PaymentCounterParty::set_has_purse() {
  _oneof_case_[0] = kPurse;
}
inline void PaymentCounterParty::clear_purse() {
  if (_internal_has_purse()) {
    if (GetArena() == nullptr) {
      delete party_.purse_;
    }
    clear_has_party();
  }
}
inline ::com::elarian::hera::proto::PaymentPurseCounterParty* PaymentCounterParty::release_purse() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentCounterParty.purse)
  if (_internal_has_purse()) {
    clear_has_party();
      ::com::elarian::hera::proto::PaymentPurseCounterParty* temp = party_.purse_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    party_.purse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::elarian::hera::proto::PaymentPurseCounterParty& PaymentCounterParty::_internal_purse() const {
  return _internal_has_purse()
      ? *party_.purse_
      : reinterpret_cast< ::com::elarian::hera::proto::PaymentPurseCounterParty&>(::com::elarian::hera::proto::_PaymentPurseCounterParty_default_instance_);
}
inline const ::com::elarian::hera::proto::PaymentPurseCounterParty& PaymentCounterParty::purse() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentCounterParty.purse)
  return _internal_purse();
}
inline ::com::elarian::hera::proto::PaymentPurseCounterParty* PaymentCounterParty::unsafe_arena_release_purse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.elarian.hera.proto.PaymentCounterParty.purse)
  if (_internal_has_purse()) {
    clear_has_party();
    ::com::elarian::hera::proto::PaymentPurseCounterParty* temp = party_.purse_;
    party_.purse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PaymentCounterParty::unsafe_arena_set_allocated_purse(::com::elarian::hera::proto::PaymentPurseCounterParty* purse) {
  clear_party();
  if (purse) {
    set_has_purse();
    party_.purse_ = purse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentCounterParty.purse)
}
inline ::com::elarian::hera::proto::PaymentPurseCounterParty* PaymentCounterParty::_internal_mutable_purse() {
  if (!_internal_has_purse()) {
    clear_party();
    set_has_purse();
    party_.purse_ = CreateMaybeMessage< ::com::elarian::hera::proto::PaymentPurseCounterParty >(GetArena());
  }
  return party_.purse_;
}
inline ::com::elarian::hera::proto::PaymentPurseCounterParty* PaymentCounterParty::mutable_purse() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentCounterParty.purse)
  return _internal_mutable_purse();
}

// .com.elarian.hera.proto.PaymentWalletCounterParty wallet = 2;
inline bool PaymentCounterParty::_internal_has_wallet() const {
  return party_case() == kWallet;
}
inline bool PaymentCounterParty::has_wallet() const {
  return _internal_has_wallet();
}
inline void PaymentCounterParty::set_has_wallet() {
  _oneof_case_[0] = kWallet;
}
inline void PaymentCounterParty::clear_wallet() {
  if (_internal_has_wallet()) {
    if (GetArena() == nullptr) {
      delete party_.wallet_;
    }
    clear_has_party();
  }
}
inline ::com::elarian::hera::proto::PaymentWalletCounterParty* PaymentCounterParty::release_wallet() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentCounterParty.wallet)
  if (_internal_has_wallet()) {
    clear_has_party();
      ::com::elarian::hera::proto::PaymentWalletCounterParty* temp = party_.wallet_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    party_.wallet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::elarian::hera::proto::PaymentWalletCounterParty& PaymentCounterParty::_internal_wallet() const {
  return _internal_has_wallet()
      ? *party_.wallet_
      : reinterpret_cast< ::com::elarian::hera::proto::PaymentWalletCounterParty&>(::com::elarian::hera::proto::_PaymentWalletCounterParty_default_instance_);
}
inline const ::com::elarian::hera::proto::PaymentWalletCounterParty& PaymentCounterParty::wallet() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentCounterParty.wallet)
  return _internal_wallet();
}
inline ::com::elarian::hera::proto::PaymentWalletCounterParty* PaymentCounterParty::unsafe_arena_release_wallet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.elarian.hera.proto.PaymentCounterParty.wallet)
  if (_internal_has_wallet()) {
    clear_has_party();
    ::com::elarian::hera::proto::PaymentWalletCounterParty* temp = party_.wallet_;
    party_.wallet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PaymentCounterParty::unsafe_arena_set_allocated_wallet(::com::elarian::hera::proto::PaymentWalletCounterParty* wallet) {
  clear_party();
  if (wallet) {
    set_has_wallet();
    party_.wallet_ = wallet;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentCounterParty.wallet)
}
inline ::com::elarian::hera::proto::PaymentWalletCounterParty* PaymentCounterParty::_internal_mutable_wallet() {
  if (!_internal_has_wallet()) {
    clear_party();
    set_has_wallet();
    party_.wallet_ = CreateMaybeMessage< ::com::elarian::hera::proto::PaymentWalletCounterParty >(GetArena());
  }
  return party_.wallet_;
}
inline ::com::elarian::hera::proto::PaymentWalletCounterParty* PaymentCounterParty::mutable_wallet() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentCounterParty.wallet)
  return _internal_mutable_wallet();
}

// .com.elarian.hera.proto.PaymentCustomerCounterParty customer = 3;
inline bool PaymentCounterParty::_internal_has_customer() const {
  return party_case() == kCustomer;
}
inline bool PaymentCounterParty::has_customer() const {
  return _internal_has_customer();
}
inline void PaymentCounterParty::set_has_customer() {
  _oneof_case_[0] = kCustomer;
}
inline void PaymentCounterParty::clear_customer() {
  if (_internal_has_customer()) {
    if (GetArena() == nullptr) {
      delete party_.customer_;
    }
    clear_has_party();
  }
}
inline ::com::elarian::hera::proto::PaymentCustomerCounterParty* PaymentCounterParty::release_customer() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentCounterParty.customer)
  if (_internal_has_customer()) {
    clear_has_party();
      ::com::elarian::hera::proto::PaymentCustomerCounterParty* temp = party_.customer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    party_.customer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::elarian::hera::proto::PaymentCustomerCounterParty& PaymentCounterParty::_internal_customer() const {
  return _internal_has_customer()
      ? *party_.customer_
      : reinterpret_cast< ::com::elarian::hera::proto::PaymentCustomerCounterParty&>(::com::elarian::hera::proto::_PaymentCustomerCounterParty_default_instance_);
}
inline const ::com::elarian::hera::proto::PaymentCustomerCounterParty& PaymentCounterParty::customer() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentCounterParty.customer)
  return _internal_customer();
}
inline ::com::elarian::hera::proto::PaymentCustomerCounterParty* PaymentCounterParty::unsafe_arena_release_customer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.elarian.hera.proto.PaymentCounterParty.customer)
  if (_internal_has_customer()) {
    clear_has_party();
    ::com::elarian::hera::proto::PaymentCustomerCounterParty* temp = party_.customer_;
    party_.customer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PaymentCounterParty::unsafe_arena_set_allocated_customer(::com::elarian::hera::proto::PaymentCustomerCounterParty* customer) {
  clear_party();
  if (customer) {
    set_has_customer();
    party_.customer_ = customer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentCounterParty.customer)
}
inline ::com::elarian::hera::proto::PaymentCustomerCounterParty* PaymentCounterParty::_internal_mutable_customer() {
  if (!_internal_has_customer()) {
    clear_party();
    set_has_customer();
    party_.customer_ = CreateMaybeMessage< ::com::elarian::hera::proto::PaymentCustomerCounterParty >(GetArena());
  }
  return party_.customer_;
}
inline ::com::elarian::hera::proto::PaymentCustomerCounterParty* PaymentCounterParty::mutable_customer() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentCounterParty.customer)
  return _internal_mutable_customer();
}

// .com.elarian.hera.proto.PaymentChannelCounterParty channel = 4;
inline bool PaymentCounterParty::_internal_has_channel() const {
  return party_case() == kChannel;
}
inline bool PaymentCounterParty::has_channel() const {
  return _internal_has_channel();
}
inline void PaymentCounterParty::set_has_channel() {
  _oneof_case_[0] = kChannel;
}
inline void PaymentCounterParty::clear_channel() {
  if (_internal_has_channel()) {
    if (GetArena() == nullptr) {
      delete party_.channel_;
    }
    clear_has_party();
  }
}
inline ::com::elarian::hera::proto::PaymentChannelCounterParty* PaymentCounterParty::release_channel() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentCounterParty.channel)
  if (_internal_has_channel()) {
    clear_has_party();
      ::com::elarian::hera::proto::PaymentChannelCounterParty* temp = party_.channel_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    party_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::elarian::hera::proto::PaymentChannelCounterParty& PaymentCounterParty::_internal_channel() const {
  return _internal_has_channel()
      ? *party_.channel_
      : reinterpret_cast< ::com::elarian::hera::proto::PaymentChannelCounterParty&>(::com::elarian::hera::proto::_PaymentChannelCounterParty_default_instance_);
}
inline const ::com::elarian::hera::proto::PaymentChannelCounterParty& PaymentCounterParty::channel() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentCounterParty.channel)
  return _internal_channel();
}
inline ::com::elarian::hera::proto::PaymentChannelCounterParty* PaymentCounterParty::unsafe_arena_release_channel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.elarian.hera.proto.PaymentCounterParty.channel)
  if (_internal_has_channel()) {
    clear_has_party();
    ::com::elarian::hera::proto::PaymentChannelCounterParty* temp = party_.channel_;
    party_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PaymentCounterParty::unsafe_arena_set_allocated_channel(::com::elarian::hera::proto::PaymentChannelCounterParty* channel) {
  clear_party();
  if (channel) {
    set_has_channel();
    party_.channel_ = channel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentCounterParty.channel)
}
inline ::com::elarian::hera::proto::PaymentChannelCounterParty* PaymentCounterParty::_internal_mutable_channel() {
  if (!_internal_has_channel()) {
    clear_party();
    set_has_channel();
    party_.channel_ = CreateMaybeMessage< ::com::elarian::hera::proto::PaymentChannelCounterParty >(GetArena());
  }
  return party_.channel_;
}
inline ::com::elarian::hera::proto::PaymentChannelCounterParty* PaymentCounterParty::mutable_channel() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentCounterParty.channel)
  return _internal_mutable_channel();
}

inline bool PaymentCounterParty::has_party() const {
  return party_case() != PARTY_NOT_SET;
}
inline void PaymentCounterParty::clear_has_party() {
  _oneof_case_[0] = PARTY_NOT_SET;
}
inline PaymentCounterParty::PartyCase PaymentCounterParty::party_case() const {
  return PaymentCounterParty::PartyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PaymentTransaction

// string transaction_id = 1;
inline void PaymentTransaction::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
}
inline const std::string& PaymentTransaction::transaction_id() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentTransaction.transaction_id)
  return _internal_transaction_id();
}
inline void PaymentTransaction::set_transaction_id(const std::string& value) {
  _internal_set_transaction_id(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentTransaction.transaction_id)
}
inline std::string* PaymentTransaction::mutable_transaction_id() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentTransaction.transaction_id)
  return _internal_mutable_transaction_id();
}
inline const std::string& PaymentTransaction::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void PaymentTransaction::_internal_set_transaction_id(const std::string& value) {
  
  transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PaymentTransaction::set_transaction_id(std::string&& value) {
  
  transaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.PaymentTransaction.transaction_id)
}
inline void PaymentTransaction::set_transaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.PaymentTransaction.transaction_id)
}
inline void PaymentTransaction::set_transaction_id(const char* value,
    size_t size) {
  
  transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.PaymentTransaction.transaction_id)
}
inline std::string* PaymentTransaction::_internal_mutable_transaction_id() {
  
  return transaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PaymentTransaction::release_transaction_id() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentTransaction.transaction_id)
  return transaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PaymentTransaction::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  transaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentTransaction.transaction_id)
}

// .google.protobuf.StringValue app_id = 2;
inline bool PaymentTransaction::_internal_has_app_id() const {
  return this != internal_default_instance() && app_id_ != nullptr;
}
inline bool PaymentTransaction::has_app_id() const {
  return _internal_has_app_id();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& PaymentTransaction::_internal_app_id() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = app_id_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& PaymentTransaction::app_id() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentTransaction.app_id)
  return _internal_app_id();
}
inline void PaymentTransaction::unsafe_arena_set_allocated_app_id(
    PROTOBUF_NAMESPACE_ID::StringValue* app_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_id_);
  }
  app_id_ = app_id;
  if (app_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentTransaction.app_id)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentTransaction::release_app_id() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = app_id_;
  app_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentTransaction::unsafe_arena_release_app_id() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentTransaction.app_id)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = app_id_;
  app_id_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentTransaction::_internal_mutable_app_id() {
  
  if (app_id_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    app_id_ = p;
  }
  return app_id_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentTransaction::mutable_app_id() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentTransaction.app_id)
  return _internal_mutable_app_id();
}
inline void PaymentTransaction::set_allocated_app_id(PROTOBUF_NAMESPACE_ID::StringValue* app_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_id_);
  }
  if (app_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_id)->GetArena();
    if (message_arena != submessage_arena) {
      app_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_id, submessage_arena);
    }
    
  } else {
    
  }
  app_id_ = app_id;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentTransaction.app_id)
}

// .com.elarian.hera.proto.PaymentCounterParty debit_party = 4;
inline bool PaymentTransaction::_internal_has_debit_party() const {
  return this != internal_default_instance() && debit_party_ != nullptr;
}
inline bool PaymentTransaction::has_debit_party() const {
  return _internal_has_debit_party();
}
inline void PaymentTransaction::clear_debit_party() {
  if (GetArena() == nullptr && debit_party_ != nullptr) {
    delete debit_party_;
  }
  debit_party_ = nullptr;
}
inline const ::com::elarian::hera::proto::PaymentCounterParty& PaymentTransaction::_internal_debit_party() const {
  const ::com::elarian::hera::proto::PaymentCounterParty* p = debit_party_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::PaymentCounterParty&>(
      ::com::elarian::hera::proto::_PaymentCounterParty_default_instance_);
}
inline const ::com::elarian::hera::proto::PaymentCounterParty& PaymentTransaction::debit_party() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentTransaction.debit_party)
  return _internal_debit_party();
}
inline void PaymentTransaction::unsafe_arena_set_allocated_debit_party(
    ::com::elarian::hera::proto::PaymentCounterParty* debit_party) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(debit_party_);
  }
  debit_party_ = debit_party;
  if (debit_party) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentTransaction.debit_party)
}
inline ::com::elarian::hera::proto::PaymentCounterParty* PaymentTransaction::release_debit_party() {
  
  ::com::elarian::hera::proto::PaymentCounterParty* temp = debit_party_;
  debit_party_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::PaymentCounterParty* PaymentTransaction::unsafe_arena_release_debit_party() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentTransaction.debit_party)
  
  ::com::elarian::hera::proto::PaymentCounterParty* temp = debit_party_;
  debit_party_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::PaymentCounterParty* PaymentTransaction::_internal_mutable_debit_party() {
  
  if (debit_party_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::PaymentCounterParty>(GetArena());
    debit_party_ = p;
  }
  return debit_party_;
}
inline ::com::elarian::hera::proto::PaymentCounterParty* PaymentTransaction::mutable_debit_party() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentTransaction.debit_party)
  return _internal_mutable_debit_party();
}
inline void PaymentTransaction::set_allocated_debit_party(::com::elarian::hera::proto::PaymentCounterParty* debit_party) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete debit_party_;
  }
  if (debit_party) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(debit_party);
    if (message_arena != submessage_arena) {
      debit_party = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debit_party, submessage_arena);
    }
    
  } else {
    
  }
  debit_party_ = debit_party;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentTransaction.debit_party)
}

// .com.elarian.hera.proto.PaymentCounterParty credit_party = 5;
inline bool PaymentTransaction::_internal_has_credit_party() const {
  return this != internal_default_instance() && credit_party_ != nullptr;
}
inline bool PaymentTransaction::has_credit_party() const {
  return _internal_has_credit_party();
}
inline void PaymentTransaction::clear_credit_party() {
  if (GetArena() == nullptr && credit_party_ != nullptr) {
    delete credit_party_;
  }
  credit_party_ = nullptr;
}
inline const ::com::elarian::hera::proto::PaymentCounterParty& PaymentTransaction::_internal_credit_party() const {
  const ::com::elarian::hera::proto::PaymentCounterParty* p = credit_party_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::PaymentCounterParty&>(
      ::com::elarian::hera::proto::_PaymentCounterParty_default_instance_);
}
inline const ::com::elarian::hera::proto::PaymentCounterParty& PaymentTransaction::credit_party() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentTransaction.credit_party)
  return _internal_credit_party();
}
inline void PaymentTransaction::unsafe_arena_set_allocated_credit_party(
    ::com::elarian::hera::proto::PaymentCounterParty* credit_party) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(credit_party_);
  }
  credit_party_ = credit_party;
  if (credit_party) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentTransaction.credit_party)
}
inline ::com::elarian::hera::proto::PaymentCounterParty* PaymentTransaction::release_credit_party() {
  
  ::com::elarian::hera::proto::PaymentCounterParty* temp = credit_party_;
  credit_party_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::PaymentCounterParty* PaymentTransaction::unsafe_arena_release_credit_party() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentTransaction.credit_party)
  
  ::com::elarian::hera::proto::PaymentCounterParty* temp = credit_party_;
  credit_party_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::PaymentCounterParty* PaymentTransaction::_internal_mutable_credit_party() {
  
  if (credit_party_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::PaymentCounterParty>(GetArena());
    credit_party_ = p;
  }
  return credit_party_;
}
inline ::com::elarian::hera::proto::PaymentCounterParty* PaymentTransaction::mutable_credit_party() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentTransaction.credit_party)
  return _internal_mutable_credit_party();
}
inline void PaymentTransaction::set_allocated_credit_party(::com::elarian::hera::proto::PaymentCounterParty* credit_party) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete credit_party_;
  }
  if (credit_party) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(credit_party);
    if (message_arena != submessage_arena) {
      credit_party = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credit_party, submessage_arena);
    }
    
  } else {
    
  }
  credit_party_ = credit_party;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentTransaction.credit_party)
}

// .com.elarian.hera.proto.Cash value = 6;
inline bool PaymentTransaction::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool PaymentTransaction::has_value() const {
  return _internal_has_value();
}
inline const ::com::elarian::hera::proto::Cash& PaymentTransaction::_internal_value() const {
  const ::com::elarian::hera::proto::Cash* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::Cash&>(
      ::com::elarian::hera::proto::_Cash_default_instance_);
}
inline const ::com::elarian::hera::proto::Cash& PaymentTransaction::value() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentTransaction.value)
  return _internal_value();
}
inline void PaymentTransaction::unsafe_arena_set_allocated_value(
    ::com::elarian::hera::proto::Cash* value) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentTransaction.value)
}
inline ::com::elarian::hera::proto::Cash* PaymentTransaction::release_value() {
  
  ::com::elarian::hera::proto::Cash* temp = value_;
  value_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PaymentTransaction::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentTransaction.value)
  
  ::com::elarian::hera::proto::Cash* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::Cash* PaymentTransaction::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::Cash>(GetArena());
    value_ = p;
  }
  return value_;
}
inline ::com::elarian::hera::proto::Cash* PaymentTransaction::mutable_value() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentTransaction.value)
  return _internal_mutable_value();
}
inline void PaymentTransaction::set_allocated_value(::com::elarian::hera::proto::Cash* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentTransaction.value)
}

// .com.elarian.hera.proto.PaymentStatus status = 7;
inline void PaymentTransaction::clear_status() {
  status_ = 0;
}
inline ::com::elarian::hera::proto::PaymentStatus PaymentTransaction::_internal_status() const {
  return static_cast< ::com::elarian::hera::proto::PaymentStatus >(status_);
}
inline ::com::elarian::hera::proto::PaymentStatus PaymentTransaction::status() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentTransaction.status)
  return _internal_status();
}
inline void PaymentTransaction::_internal_set_status(::com::elarian::hera::proto::PaymentStatus value) {
  
  status_ = value;
}
inline void PaymentTransaction::set_status(::com::elarian::hera::proto::PaymentStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.PaymentTransaction.status)
}

// .google.protobuf.Timestamp created_at = 8;
inline bool PaymentTransaction::_internal_has_created_at() const {
  return this != internal_default_instance() && created_at_ != nullptr;
}
inline bool PaymentTransaction::has_created_at() const {
  return _internal_has_created_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PaymentTransaction::_internal_created_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = created_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PaymentTransaction::created_at() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentTransaction.created_at)
  return _internal_created_at();
}
inline void PaymentTransaction::unsafe_arena_set_allocated_created_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentTransaction.created_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PaymentTransaction::release_created_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PaymentTransaction::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentTransaction.created_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_at_;
  created_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PaymentTransaction::_internal_mutable_created_at() {
  
  if (created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    created_at_ = p;
  }
  return created_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PaymentTransaction::mutable_created_at() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentTransaction.created_at)
  return _internal_mutable_created_at();
}
inline void PaymentTransaction::set_allocated_created_at(PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at)->GetArena();
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentTransaction.created_at)
}

// .google.protobuf.Timestamp updated_at = 9;
inline bool PaymentTransaction::_internal_has_updated_at() const {
  return this != internal_default_instance() && updated_at_ != nullptr;
}
inline bool PaymentTransaction::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PaymentTransaction::_internal_updated_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PaymentTransaction::updated_at() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentTransaction.updated_at)
  return _internal_updated_at();
}
inline void PaymentTransaction::unsafe_arena_set_allocated_updated_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentTransaction.updated_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PaymentTransaction::release_updated_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PaymentTransaction::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentTransaction.updated_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = updated_at_;
  updated_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PaymentTransaction::_internal_mutable_updated_at() {
  
  if (updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    updated_at_ = p;
  }
  return updated_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PaymentTransaction::mutable_updated_at() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentTransaction.updated_at)
  return _internal_mutable_updated_at();
}
inline void PaymentTransaction::set_allocated_updated_at(PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at)->GetArena();
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentTransaction.updated_at)
}

// .google.protobuf.StringValue provider_transaction_id = 10;
inline bool PaymentTransaction::_internal_has_provider_transaction_id() const {
  return this != internal_default_instance() && provider_transaction_id_ != nullptr;
}
inline bool PaymentTransaction::has_provider_transaction_id() const {
  return _internal_has_provider_transaction_id();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& PaymentTransaction::_internal_provider_transaction_id() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = provider_transaction_id_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& PaymentTransaction::provider_transaction_id() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.PaymentTransaction.provider_transaction_id)
  return _internal_provider_transaction_id();
}
inline void PaymentTransaction::unsafe_arena_set_allocated_provider_transaction_id(
    PROTOBUF_NAMESPACE_ID::StringValue* provider_transaction_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider_transaction_id_);
  }
  provider_transaction_id_ = provider_transaction_id;
  if (provider_transaction_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.PaymentTransaction.provider_transaction_id)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentTransaction::release_provider_transaction_id() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = provider_transaction_id_;
  provider_transaction_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentTransaction::unsafe_arena_release_provider_transaction_id() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.PaymentTransaction.provider_transaction_id)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = provider_transaction_id_;
  provider_transaction_id_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentTransaction::_internal_mutable_provider_transaction_id() {
  
  if (provider_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    provider_transaction_id_ = p;
  }
  return provider_transaction_id_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* PaymentTransaction::mutable_provider_transaction_id() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.PaymentTransaction.provider_transaction_id)
  return _internal_mutable_provider_transaction_id();
}
inline void PaymentTransaction::set_allocated_provider_transaction_id(PROTOBUF_NAMESPACE_ID::StringValue* provider_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider_transaction_id_);
  }
  if (provider_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider_transaction_id)->GetArena();
    if (message_arena != submessage_arena) {
      provider_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, provider_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  provider_transaction_id_ = provider_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.PaymentTransaction.provider_transaction_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace hera
}  // namespace elarian
}  // namespace com

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::com::elarian::hera::proto::PaymentChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::elarian::hera::proto::PaymentChannel>() {
  return ::com::elarian::hera::proto::PaymentChannel_descriptor();
}
template <> struct is_proto_enum< ::com::elarian::hera::proto::PaymentStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::elarian::hera::proto::PaymentStatus>() {
  return ::com::elarian::hera::proto::PaymentStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_payment_5fmodel_2eproto
