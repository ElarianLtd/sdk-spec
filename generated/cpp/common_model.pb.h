// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common_model.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_5fmodel_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_5fmodel_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_5fmodel_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_5fmodel_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_5fmodel_2eproto;
namespace com {
namespace elarian {
namespace hera {
namespace proto {
class AppConnectionProps;
class AppConnectionPropsDefaultTypeInternal;
extern AppConnectionPropsDefaultTypeInternal _AppConnectionProps_default_instance_;
class Cash;
class CashDefaultTypeInternal;
extern CashDefaultTypeInternal _Cash_default_instance_;
class CustomerIndex;
class CustomerIndexDefaultTypeInternal;
extern CustomerIndexDefaultTypeInternal _CustomerIndex_default_instance_;
class CustomerNumber;
class CustomerNumberDefaultTypeInternal;
extern CustomerNumberDefaultTypeInternal _CustomerNumber_default_instance_;
class DataMapValue;
class DataMapValueDefaultTypeInternal;
extern DataMapValueDefaultTypeInternal _DataMapValue_default_instance_;
class IndexMapping;
class IndexMappingDefaultTypeInternal;
extern IndexMappingDefaultTypeInternal _IndexMapping_default_instance_;
}  // namespace proto
}  // namespace hera
}  // namespace elarian
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::elarian::hera::proto::AppConnectionProps* Arena::CreateMaybeMessage<::com::elarian::hera::proto::AppConnectionProps>(Arena*);
template<> ::com::elarian::hera::proto::Cash* Arena::CreateMaybeMessage<::com::elarian::hera::proto::Cash>(Arena*);
template<> ::com::elarian::hera::proto::CustomerIndex* Arena::CreateMaybeMessage<::com::elarian::hera::proto::CustomerIndex>(Arena*);
template<> ::com::elarian::hera::proto::CustomerNumber* Arena::CreateMaybeMessage<::com::elarian::hera::proto::CustomerNumber>(Arena*);
template<> ::com::elarian::hera::proto::DataMapValue* Arena::CreateMaybeMessage<::com::elarian::hera::proto::DataMapValue>(Arena*);
template<> ::com::elarian::hera::proto::IndexMapping* Arena::CreateMaybeMessage<::com::elarian::hera::proto::IndexMapping>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace elarian {
namespace hera {
namespace proto {

enum CustomerNumberProvider : int {
  CUSTOMER_NUMBER_PROVIDER_UNSPECIFIED = 0,
  CUSTOMER_NUMBER_PROVIDER_FACEBOOK = 1,
  CUSTOMER_NUMBER_PROVIDER_CELLULAR = 2,
  CUSTOMER_NUMBER_PROVIDER_TELEGRAM = 3,
  CUSTOMER_NUMBER_PROVIDER_APP = 4,
  CUSTOMER_NUMBER_PROVIDER_EMAIL = 5,
  CustomerNumberProvider_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CustomerNumberProvider_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CustomerNumberProvider_IsValid(int value);
constexpr CustomerNumberProvider CustomerNumberProvider_MIN = CUSTOMER_NUMBER_PROVIDER_UNSPECIFIED;
constexpr CustomerNumberProvider CustomerNumberProvider_MAX = CUSTOMER_NUMBER_PROVIDER_EMAIL;
constexpr int CustomerNumberProvider_ARRAYSIZE = CustomerNumberProvider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CustomerNumberProvider_descriptor();
template<typename T>
inline const std::string& CustomerNumberProvider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomerNumberProvider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomerNumberProvider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CustomerNumberProvider_descriptor(), enum_t_value);
}
inline bool CustomerNumberProvider_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CustomerNumberProvider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CustomerNumberProvider>(
    CustomerNumberProvider_descriptor(), name, value);
}
enum ChannelNumberProvider : int {
  CHANNEL_NUMBER_PROVIDER_UNSPECIFIED = 0,
  CHANNEL_NUMBER_PROVIDER_AT = 1,
  CHANNEL_NUMBER_PROVIDER_TWILIO = 2,
  CHANNEL_NUMBER_PROVIDER_MAILGUN = 3,
  CHANNEL_NUMBER_PROVIDER_FACEBOOK = 4,
  CHANNEL_NUMBER_PROVIDER_TELEGRAM = 5,
  CHANNEL_NUMBER_PROVIDER_MPESA = 6,
  ChannelNumberProvider_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChannelNumberProvider_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChannelNumberProvider_IsValid(int value);
constexpr ChannelNumberProvider ChannelNumberProvider_MIN = CHANNEL_NUMBER_PROVIDER_UNSPECIFIED;
constexpr ChannelNumberProvider ChannelNumberProvider_MAX = CHANNEL_NUMBER_PROVIDER_MPESA;
constexpr int ChannelNumberProvider_ARRAYSIZE = ChannelNumberProvider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelNumberProvider_descriptor();
template<typename T>
inline const std::string& ChannelNumberProvider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelNumberProvider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelNumberProvider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelNumberProvider_descriptor(), enum_t_value);
}
inline bool ChannelNumberProvider_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChannelNumberProvider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelNumberProvider>(
    ChannelNumberProvider_descriptor(), name, value);
}
enum MediaType : int {
  MEDIA_TYPE_UNSPECIFIED = 0,
  MEDIA_TYPE_IMAGE = 1,
  MEDIA_TYPE_AUDIO = 2,
  MEDIA_TYPE_VIDEO = 3,
  MEDIA_TYPE_DOCUMENT = 4,
  MEDIA_TYPE_VOICE = 5,
  MEDIA_TYPE_STICKER = 6,
  MEDIA_TYPE_CONTACT = 7,
  MediaType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MediaType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MediaType_IsValid(int value);
constexpr MediaType MediaType_MIN = MEDIA_TYPE_UNSPECIFIED;
constexpr MediaType MediaType_MAX = MEDIA_TYPE_CONTACT;
constexpr int MediaType_ARRAYSIZE = MediaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MediaType_descriptor();
template<typename T>
inline const std::string& MediaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MediaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MediaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MediaType_descriptor(), enum_t_value);
}
inline bool MediaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MediaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MediaType>(
    MediaType_descriptor(), name, value);
}
enum CustomerEventDirection : int {
  CUSTOMER_EVENT_DIRECTION_UNSPECIFIED = 0,
  CUSTOMER_EVENT_DIRECTION_INBOUND = 1,
  CUSTOMER_EVENT_DIRECTION_OUTBOUND = 2,
  CustomerEventDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CustomerEventDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CustomerEventDirection_IsValid(int value);
constexpr CustomerEventDirection CustomerEventDirection_MIN = CUSTOMER_EVENT_DIRECTION_UNSPECIFIED;
constexpr CustomerEventDirection CustomerEventDirection_MAX = CUSTOMER_EVENT_DIRECTION_OUTBOUND;
constexpr int CustomerEventDirection_ARRAYSIZE = CustomerEventDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CustomerEventDirection_descriptor();
template<typename T>
inline const std::string& CustomerEventDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomerEventDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomerEventDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CustomerEventDirection_descriptor(), enum_t_value);
}
inline bool CustomerEventDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CustomerEventDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CustomerEventDirection>(
    CustomerEventDirection_descriptor(), name, value);
}
enum CustomerRequestOrigin : int {
  CUSTOMER_REQUEST_ORIGIN_UNSPECIFIED = 0,
  CUSTOMER_REQUEST_ORIGIN_API_REQUEST = 1,
  CUSTOMER_REQUEST_ORIGIN_CUSTOMER_TAG = 2,
  CUSTOMER_REQUEST_ORIGIN_REPLAY = 3,
  CustomerRequestOrigin_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CustomerRequestOrigin_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CustomerRequestOrigin_IsValid(int value);
constexpr CustomerRequestOrigin CustomerRequestOrigin_MIN = CUSTOMER_REQUEST_ORIGIN_UNSPECIFIED;
constexpr CustomerRequestOrigin CustomerRequestOrigin_MAX = CUSTOMER_REQUEST_ORIGIN_REPLAY;
constexpr int CustomerRequestOrigin_ARRAYSIZE = CustomerRequestOrigin_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CustomerRequestOrigin_descriptor();
template<typename T>
inline const std::string& CustomerRequestOrigin_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomerRequestOrigin>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomerRequestOrigin_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CustomerRequestOrigin_descriptor(), enum_t_value);
}
inline bool CustomerRequestOrigin_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CustomerRequestOrigin* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CustomerRequestOrigin>(
    CustomerRequestOrigin_descriptor(), name, value);
}
// ===================================================================

class DataMapValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.DataMapValue) */ {
 public:
  inline DataMapValue() : DataMapValue(nullptr) {}
  virtual ~DataMapValue();

  DataMapValue(const DataMapValue& from);
  DataMapValue(DataMapValue&& from) noexcept
    : DataMapValue() {
    *this = ::std::move(from);
  }

  inline DataMapValue& operator=(const DataMapValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMapValue& operator=(DataMapValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataMapValue& default_instance();

  enum ValueCase {
    kStringVal = 2,
    kBytesVal = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const DataMapValue* internal_default_instance() {
    return reinterpret_cast<const DataMapValue*>(
               &_DataMapValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DataMapValue& a, DataMapValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMapValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMapValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataMapValue* New() const final {
    return CreateMaybeMessage<DataMapValue>(nullptr);
  }

  DataMapValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataMapValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataMapValue& from);
  void MergeFrom(const DataMapValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMapValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.DataMapValue";
  }
  protected:
  explicit DataMapValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_common_5fmodel_2eproto);
    return ::descriptor_table_common_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValFieldNumber = 2,
    kBytesValFieldNumber = 3,
  };
  // string string_val = 2;
  private:
  bool _internal_has_string_val() const;
  public:
  void clear_string_val();
  const std::string& string_val() const;
  void set_string_val(const std::string& value);
  void set_string_val(std::string&& value);
  void set_string_val(const char* value);
  void set_string_val(const char* value, size_t size);
  std::string* mutable_string_val();
  std::string* release_string_val();
  void set_allocated_string_val(std::string* string_val);
  private:
  const std::string& _internal_string_val() const;
  void _internal_set_string_val(const std::string& value);
  std::string* _internal_mutable_string_val();
  public:

  // bytes bytes_val = 3;
  private:
  bool _internal_has_bytes_val() const;
  public:
  void clear_bytes_val();
  const std::string& bytes_val() const;
  void set_bytes_val(const std::string& value);
  void set_bytes_val(std::string&& value);
  void set_bytes_val(const char* value);
  void set_bytes_val(const void* value, size_t size);
  std::string* mutable_bytes_val();
  std::string* release_bytes_val();
  void set_allocated_bytes_val(std::string* bytes_val);
  private:
  const std::string& _internal_bytes_val() const;
  void _internal_set_bytes_val(const std::string& value);
  std::string* _internal_mutable_bytes_val();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.DataMapValue)
 private:
  class _Internal;
  void set_has_string_val();
  void set_has_bytes_val();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    ValueUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_val_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_common_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Cash PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.Cash) */ {
 public:
  inline Cash() : Cash(nullptr) {}
  virtual ~Cash();

  Cash(const Cash& from);
  Cash(Cash&& from) noexcept
    : Cash() {
    *this = ::std::move(from);
  }

  inline Cash& operator=(const Cash& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cash& operator=(Cash&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Cash& default_instance();

  static inline const Cash* internal_default_instance() {
    return reinterpret_cast<const Cash*>(
               &_Cash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Cash& a, Cash& b) {
    a.Swap(&b);
  }
  inline void Swap(Cash* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cash* New() const final {
    return CreateMaybeMessage<Cash>(nullptr);
  }

  Cash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cash>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cash& from);
  void MergeFrom(const Cash& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cash* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.Cash";
  }
  protected:
  explicit Cash(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_common_5fmodel_2eproto);
    return ::descriptor_table_common_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodeFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string currency_code = 1;
  void clear_currency_code();
  const std::string& currency_code() const;
  void set_currency_code(const std::string& value);
  void set_currency_code(std::string&& value);
  void set_currency_code(const char* value);
  void set_currency_code(const char* value, size_t size);
  std::string* mutable_currency_code();
  std::string* release_currency_code();
  void set_allocated_currency_code(std::string* currency_code);
  private:
  const std::string& _internal_currency_code() const;
  void _internal_set_currency_code(const std::string& value);
  std::string* _internal_mutable_currency_code();
  public:

  // double amount = 2;
  void clear_amount();
  double amount() const;
  void set_amount(double value);
  private:
  double _internal_amount() const;
  void _internal_set_amount(double value);
  public:

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.Cash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_code_;
  double amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class IndexMapping PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.IndexMapping) */ {
 public:
  inline IndexMapping() : IndexMapping(nullptr) {}
  virtual ~IndexMapping();

  IndexMapping(const IndexMapping& from);
  IndexMapping(IndexMapping&& from) noexcept
    : IndexMapping() {
    *this = ::std::move(from);
  }

  inline IndexMapping& operator=(const IndexMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexMapping& operator=(IndexMapping&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IndexMapping& default_instance();

  static inline const IndexMapping* internal_default_instance() {
    return reinterpret_cast<const IndexMapping*>(
               &_IndexMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IndexMapping& a, IndexMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexMapping* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexMapping* New() const final {
    return CreateMaybeMessage<IndexMapping>(nullptr);
  }

  IndexMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexMapping>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IndexMapping& from);
  void MergeFrom(const IndexMapping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexMapping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.IndexMapping";
  }
  protected:
  explicit IndexMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_common_5fmodel_2eproto);
    return ::descriptor_table_common_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .google.protobuf.StringValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const PROTOBUF_NAMESPACE_ID::StringValue& value() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_value();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_value();
  void set_allocated_value(PROTOBUF_NAMESPACE_ID::StringValue* value);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_value() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      PROTOBUF_NAMESPACE_ID::StringValue* value);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.IndexMapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  PROTOBUF_NAMESPACE_ID::StringValue* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class CustomerIndex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.CustomerIndex) */ {
 public:
  inline CustomerIndex() : CustomerIndex(nullptr) {}
  virtual ~CustomerIndex();

  CustomerIndex(const CustomerIndex& from);
  CustomerIndex(CustomerIndex&& from) noexcept
    : CustomerIndex() {
    *this = ::std::move(from);
  }

  inline CustomerIndex& operator=(const CustomerIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomerIndex& operator=(CustomerIndex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomerIndex& default_instance();

  static inline const CustomerIndex* internal_default_instance() {
    return reinterpret_cast<const CustomerIndex*>(
               &_CustomerIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CustomerIndex& a, CustomerIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomerIndex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomerIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomerIndex* New() const final {
    return CreateMaybeMessage<CustomerIndex>(nullptr);
  }

  CustomerIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomerIndex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomerIndex& from);
  void MergeFrom(const CustomerIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomerIndex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.CustomerIndex";
  }
  protected:
  explicit CustomerIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_common_5fmodel_2eproto);
    return ::descriptor_table_common_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMappingFieldNumber = 1,
    kExpiresAtFieldNumber = 2,
  };
  // .com.elarian.hera.proto.IndexMapping mapping = 1;
  bool has_mapping() const;
  private:
  bool _internal_has_mapping() const;
  public:
  void clear_mapping();
  const ::com::elarian::hera::proto::IndexMapping& mapping() const;
  ::com::elarian::hera::proto::IndexMapping* release_mapping();
  ::com::elarian::hera::proto::IndexMapping* mutable_mapping();
  void set_allocated_mapping(::com::elarian::hera::proto::IndexMapping* mapping);
  private:
  const ::com::elarian::hera::proto::IndexMapping& _internal_mapping() const;
  ::com::elarian::hera::proto::IndexMapping* _internal_mutable_mapping();
  public:
  void unsafe_arena_set_allocated_mapping(
      ::com::elarian::hera::proto::IndexMapping* mapping);
  ::com::elarian::hera::proto::IndexMapping* unsafe_arena_release_mapping();

  // .google.protobuf.Timestamp expires_at = 2;
  bool has_expires_at() const;
  private:
  bool _internal_has_expires_at() const;
  public:
  void clear_expires_at();
  const PROTOBUF_NAMESPACE_ID::Timestamp& expires_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_expires_at();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expires_at() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expires_at();
  public:
  void unsafe_arena_set_allocated_expires_at(
      PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expires_at();

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.CustomerIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::com::elarian::hera::proto::IndexMapping* mapping_;
  PROTOBUF_NAMESPACE_ID::Timestamp* expires_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class AppConnectionProps PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.AppConnectionProps) */ {
 public:
  inline AppConnectionProps() : AppConnectionProps(nullptr) {}
  virtual ~AppConnectionProps();

  AppConnectionProps(const AppConnectionProps& from);
  AppConnectionProps(AppConnectionProps&& from) noexcept
    : AppConnectionProps() {
    *this = ::std::move(from);
  }

  inline AppConnectionProps& operator=(const AppConnectionProps& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppConnectionProps& operator=(AppConnectionProps&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AppConnectionProps& default_instance();

  static inline const AppConnectionProps* internal_default_instance() {
    return reinterpret_cast<const AppConnectionProps*>(
               &_AppConnectionProps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AppConnectionProps& a, AppConnectionProps& b) {
    a.Swap(&b);
  }
  inline void Swap(AppConnectionProps* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppConnectionProps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AppConnectionProps* New() const final {
    return CreateMaybeMessage<AppConnectionProps>(nullptr);
  }

  AppConnectionProps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppConnectionProps>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AppConnectionProps& from);
  void MergeFrom(const AppConnectionProps& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppConnectionProps* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.AppConnectionProps";
  }
  protected:
  explicit AppConnectionProps(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_common_5fmodel_2eproto);
    return ::descriptor_table_common_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionIdFieldNumber = 1,
    kConnectionTimeFieldNumber = 2,
    kIpAddressFieldNumber = 3,
    kSimplexModeFieldNumber = 4,
  };
  // string connection_id = 1;
  void clear_connection_id();
  const std::string& connection_id() const;
  void set_connection_id(const std::string& value);
  void set_connection_id(std::string&& value);
  void set_connection_id(const char* value);
  void set_connection_id(const char* value, size_t size);
  std::string* mutable_connection_id();
  std::string* release_connection_id();
  void set_allocated_connection_id(std::string* connection_id);
  private:
  const std::string& _internal_connection_id() const;
  void _internal_set_connection_id(const std::string& value);
  std::string* _internal_mutable_connection_id();
  public:

  // .google.protobuf.Timestamp connection_time = 2;
  bool has_connection_time() const;
  private:
  bool _internal_has_connection_time() const;
  public:
  void clear_connection_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& connection_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_connection_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_connection_time();
  void set_allocated_connection_time(PROTOBUF_NAMESPACE_ID::Timestamp* connection_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_connection_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_connection_time();
  public:
  void unsafe_arena_set_allocated_connection_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* connection_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_connection_time();

  // .google.protobuf.StringValue ip_address = 3;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const PROTOBUF_NAMESPACE_ID::StringValue& ip_address() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_ip_address();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_ip_address();
  void set_allocated_ip_address(PROTOBUF_NAMESPACE_ID::StringValue* ip_address);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_ip_address() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_ip_address();
  public:
  void unsafe_arena_set_allocated_ip_address(
      PROTOBUF_NAMESPACE_ID::StringValue* ip_address);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_ip_address();

  // bool simplex_mode = 4;
  void clear_simplex_mode();
  bool simplex_mode() const;
  void set_simplex_mode(bool value);
  private:
  bool _internal_simplex_mode() const;
  void _internal_set_simplex_mode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.AppConnectionProps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_id_;
  PROTOBUF_NAMESPACE_ID::Timestamp* connection_time_;
  PROTOBUF_NAMESPACE_ID::StringValue* ip_address_;
  bool simplex_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class CustomerNumber PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.elarian.hera.proto.CustomerNumber) */ {
 public:
  inline CustomerNumber() : CustomerNumber(nullptr) {}
  virtual ~CustomerNumber();

  CustomerNumber(const CustomerNumber& from);
  CustomerNumber(CustomerNumber&& from) noexcept
    : CustomerNumber() {
    *this = ::std::move(from);
  }

  inline CustomerNumber& operator=(const CustomerNumber& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomerNumber& operator=(CustomerNumber&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomerNumber& default_instance();

  static inline const CustomerNumber* internal_default_instance() {
    return reinterpret_cast<const CustomerNumber*>(
               &_CustomerNumber_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CustomerNumber& a, CustomerNumber& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomerNumber* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomerNumber* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomerNumber* New() const final {
    return CreateMaybeMessage<CustomerNumber>(nullptr);
  }

  CustomerNumber* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomerNumber>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomerNumber& from);
  void MergeFrom(const CustomerNumber& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomerNumber* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.elarian.hera.proto.CustomerNumber";
  }
  protected:
  explicit CustomerNumber(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_common_5fmodel_2eproto);
    return ::descriptor_table_common_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 2,
    kPartitionFieldNumber = 3,
    kProviderFieldNumber = 1,
  };
  // string number = 2;
  void clear_number();
  const std::string& number() const;
  void set_number(const std::string& value);
  void set_number(std::string&& value);
  void set_number(const char* value);
  void set_number(const char* value, size_t size);
  std::string* mutable_number();
  std::string* release_number();
  void set_allocated_number(std::string* number);
  private:
  const std::string& _internal_number() const;
  void _internal_set_number(const std::string& value);
  std::string* _internal_mutable_number();
  public:

  // .google.protobuf.StringValue partition = 3;
  bool has_partition() const;
  private:
  bool _internal_has_partition() const;
  public:
  void clear_partition();
  const PROTOBUF_NAMESPACE_ID::StringValue& partition() const;
  PROTOBUF_NAMESPACE_ID::StringValue* release_partition();
  PROTOBUF_NAMESPACE_ID::StringValue* mutable_partition();
  void set_allocated_partition(PROTOBUF_NAMESPACE_ID::StringValue* partition);
  private:
  const PROTOBUF_NAMESPACE_ID::StringValue& _internal_partition() const;
  PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_partition();
  public:
  void unsafe_arena_set_allocated_partition(
      PROTOBUF_NAMESPACE_ID::StringValue* partition);
  PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_partition();

  // .com.elarian.hera.proto.CustomerNumberProvider provider = 1;
  void clear_provider();
  ::com::elarian::hera::proto::CustomerNumberProvider provider() const;
  void set_provider(::com::elarian::hera::proto::CustomerNumberProvider value);
  private:
  ::com::elarian::hera::proto::CustomerNumberProvider _internal_provider() const;
  void _internal_set_provider(::com::elarian::hera::proto::CustomerNumberProvider value);
  public:

  // @@protoc_insertion_point(class_scope:com.elarian.hera.proto.CustomerNumber)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_;
  PROTOBUF_NAMESPACE_ID::StringValue* partition_;
  int provider_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_5fmodel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DataMapValue

// string string_val = 2;
inline bool DataMapValue::_internal_has_string_val() const {
  return value_case() == kStringVal;
}
inline void DataMapValue::set_has_string_val() {
  _oneof_case_[0] = kStringVal;
}
inline void DataMapValue::clear_string_val() {
  if (_internal_has_string_val()) {
    value_.string_val_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_value();
  }
}
inline const std::string& DataMapValue::string_val() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.DataMapValue.string_val)
  return _internal_string_val();
}
inline void DataMapValue::set_string_val(const std::string& value) {
  _internal_set_string_val(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.DataMapValue.string_val)
}
inline std::string* DataMapValue::mutable_string_val() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.DataMapValue.string_val)
  return _internal_mutable_string_val();
}
inline const std::string& DataMapValue::_internal_string_val() const {
  if (_internal_has_string_val()) {
    return value_.string_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataMapValue::_internal_set_string_val(const std::string& value) {
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMapValue::set_string_val(std::string&& value) {
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.DataMapValue.string_val)
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_val_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.DataMapValue.string_val)
}
inline void DataMapValue::set_string_val(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.DataMapValue.string_val)
}
inline void DataMapValue::set_string_val(const char* value,
                             size_t size) {
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_val_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.DataMapValue.string_val)
}
inline std::string* DataMapValue::_internal_mutable_string_val() {
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.string_val_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMapValue::release_string_val() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.DataMapValue.string_val)
  if (_internal_has_string_val()) {
    clear_has_value();
    return value_.string_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void DataMapValue::set_allocated_string_val(std::string* string_val) {
  if (has_value()) {
    clear_value();
  }
  if (string_val != nullptr) {
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(string_val);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(string_val);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.DataMapValue.string_val)
}

// bytes bytes_val = 3;
inline bool DataMapValue::_internal_has_bytes_val() const {
  return value_case() == kBytesVal;
}
inline void DataMapValue::set_has_bytes_val() {
  _oneof_case_[0] = kBytesVal;
}
inline void DataMapValue::clear_bytes_val() {
  if (_internal_has_bytes_val()) {
    value_.bytes_val_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_value();
  }
}
inline const std::string& DataMapValue::bytes_val() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.DataMapValue.bytes_val)
  return _internal_bytes_val();
}
inline void DataMapValue::set_bytes_val(const std::string& value) {
  _internal_set_bytes_val(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.DataMapValue.bytes_val)
}
inline std::string* DataMapValue::mutable_bytes_val() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.DataMapValue.bytes_val)
  return _internal_mutable_bytes_val();
}
inline const std::string& DataMapValue::_internal_bytes_val() const {
  if (_internal_has_bytes_val()) {
    return value_.bytes_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataMapValue::_internal_set_bytes_val(const std::string& value) {
  if (!_internal_has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataMapValue::set_bytes_val(std::string&& value) {
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.DataMapValue.bytes_val)
  if (!_internal_has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_val_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.DataMapValue.bytes_val)
}
inline void DataMapValue::set_bytes_val(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.DataMapValue.bytes_val)
}
inline void DataMapValue::set_bytes_val(const void* value,
                             size_t size) {
  if (!_internal_has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_val_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.DataMapValue.bytes_val)
}
inline std::string* DataMapValue::_internal_mutable_bytes_val() {
  if (!_internal_has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.bytes_val_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMapValue::release_bytes_val() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.DataMapValue.bytes_val)
  if (_internal_has_bytes_val()) {
    clear_has_value();
    return value_.bytes_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void DataMapValue::set_allocated_bytes_val(std::string* bytes_val) {
  if (has_value()) {
    clear_value();
  }
  if (bytes_val != nullptr) {
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(bytes_val);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(bytes_val);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.DataMapValue.bytes_val)
}

inline bool DataMapValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DataMapValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline DataMapValue::ValueCase DataMapValue::value_case() const {
  return DataMapValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Cash

// string currency_code = 1;
inline void Cash::clear_currency_code() {
  currency_code_.ClearToEmpty();
}
inline const std::string& Cash::currency_code() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.Cash.currency_code)
  return _internal_currency_code();
}
inline void Cash::set_currency_code(const std::string& value) {
  _internal_set_currency_code(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.Cash.currency_code)
}
inline std::string* Cash::mutable_currency_code() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.Cash.currency_code)
  return _internal_mutable_currency_code();
}
inline const std::string& Cash::_internal_currency_code() const {
  return currency_code_.Get();
}
inline void Cash::_internal_set_currency_code(const std::string& value) {
  
  currency_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Cash::set_currency_code(std::string&& value) {
  
  currency_code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.Cash.currency_code)
}
inline void Cash::set_currency_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  currency_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.Cash.currency_code)
}
inline void Cash::set_currency_code(const char* value,
    size_t size) {
  
  currency_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.Cash.currency_code)
}
inline std::string* Cash::_internal_mutable_currency_code() {
  
  return currency_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cash::release_currency_code() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.Cash.currency_code)
  return currency_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cash::set_allocated_currency_code(std::string* currency_code) {
  if (currency_code != nullptr) {
    
  } else {
    
  }
  currency_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), currency_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.Cash.currency_code)
}

// double amount = 2;
inline void Cash::clear_amount() {
  amount_ = 0;
}
inline double Cash::_internal_amount() const {
  return amount_;
}
inline double Cash::amount() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.Cash.amount)
  return _internal_amount();
}
inline void Cash::_internal_set_amount(double value) {
  
  amount_ = value;
}
inline void Cash::set_amount(double value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.Cash.amount)
}

// -------------------------------------------------------------------

// IndexMapping

// string key = 1;
inline void IndexMapping::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& IndexMapping::key() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.IndexMapping.key)
  return _internal_key();
}
inline void IndexMapping::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.IndexMapping.key)
}
inline std::string* IndexMapping::mutable_key() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.IndexMapping.key)
  return _internal_mutable_key();
}
inline const std::string& IndexMapping::_internal_key() const {
  return key_.Get();
}
inline void IndexMapping::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void IndexMapping::set_key(std::string&& value) {
  
  key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.IndexMapping.key)
}
inline void IndexMapping::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.IndexMapping.key)
}
inline void IndexMapping::set_key(const char* value,
    size_t size) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.IndexMapping.key)
}
inline std::string* IndexMapping::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* IndexMapping::release_key() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.IndexMapping.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IndexMapping::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.IndexMapping.key)
}

// .google.protobuf.StringValue value = 2;
inline bool IndexMapping::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool IndexMapping::has_value() const {
  return _internal_has_value();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& IndexMapping::_internal_value() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& IndexMapping::value() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.IndexMapping.value)
  return _internal_value();
}
inline void IndexMapping::unsafe_arena_set_allocated_value(
    PROTOBUF_NAMESPACE_ID::StringValue* value) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.IndexMapping.value)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* IndexMapping::release_value() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = value_;
  value_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* IndexMapping::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.IndexMapping.value)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* IndexMapping::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    value_ = p;
  }
  return value_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* IndexMapping::mutable_value() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.IndexMapping.value)
  return _internal_mutable_value();
}
inline void IndexMapping::set_allocated_value(PROTOBUF_NAMESPACE_ID::StringValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.IndexMapping.value)
}

// -------------------------------------------------------------------

// CustomerIndex

// .com.elarian.hera.proto.IndexMapping mapping = 1;
inline bool CustomerIndex::_internal_has_mapping() const {
  return this != internal_default_instance() && mapping_ != nullptr;
}
inline bool CustomerIndex::has_mapping() const {
  return _internal_has_mapping();
}
inline void CustomerIndex::clear_mapping() {
  if (GetArena() == nullptr && mapping_ != nullptr) {
    delete mapping_;
  }
  mapping_ = nullptr;
}
inline const ::com::elarian::hera::proto::IndexMapping& CustomerIndex::_internal_mapping() const {
  const ::com::elarian::hera::proto::IndexMapping* p = mapping_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::elarian::hera::proto::IndexMapping&>(
      ::com::elarian::hera::proto::_IndexMapping_default_instance_);
}
inline const ::com::elarian::hera::proto::IndexMapping& CustomerIndex::mapping() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.CustomerIndex.mapping)
  return _internal_mapping();
}
inline void CustomerIndex::unsafe_arena_set_allocated_mapping(
    ::com::elarian::hera::proto::IndexMapping* mapping) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapping_);
  }
  mapping_ = mapping;
  if (mapping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.CustomerIndex.mapping)
}
inline ::com::elarian::hera::proto::IndexMapping* CustomerIndex::release_mapping() {
  
  ::com::elarian::hera::proto::IndexMapping* temp = mapping_;
  mapping_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::elarian::hera::proto::IndexMapping* CustomerIndex::unsafe_arena_release_mapping() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.CustomerIndex.mapping)
  
  ::com::elarian::hera::proto::IndexMapping* temp = mapping_;
  mapping_ = nullptr;
  return temp;
}
inline ::com::elarian::hera::proto::IndexMapping* CustomerIndex::_internal_mutable_mapping() {
  
  if (mapping_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::elarian::hera::proto::IndexMapping>(GetArena());
    mapping_ = p;
  }
  return mapping_;
}
inline ::com::elarian::hera::proto::IndexMapping* CustomerIndex::mutable_mapping() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.CustomerIndex.mapping)
  return _internal_mutable_mapping();
}
inline void CustomerIndex::set_allocated_mapping(::com::elarian::hera::proto::IndexMapping* mapping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mapping_;
  }
  if (mapping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mapping);
    if (message_arena != submessage_arena) {
      mapping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapping, submessage_arena);
    }
    
  } else {
    
  }
  mapping_ = mapping;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.CustomerIndex.mapping)
}

// .google.protobuf.Timestamp expires_at = 2;
inline bool CustomerIndex::_internal_has_expires_at() const {
  return this != internal_default_instance() && expires_at_ != nullptr;
}
inline bool CustomerIndex::has_expires_at() const {
  return _internal_has_expires_at();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& CustomerIndex::_internal_expires_at() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& CustomerIndex::expires_at() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.CustomerIndex.expires_at)
  return _internal_expires_at();
}
inline void CustomerIndex::unsafe_arena_set_allocated_expires_at(
    PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at_);
  }
  expires_at_ = expires_at;
  if (expires_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.CustomerIndex.expires_at)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* CustomerIndex::release_expires_at() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = expires_at_;
  expires_at_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* CustomerIndex::unsafe_arena_release_expires_at() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.CustomerIndex.expires_at)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = expires_at_;
  expires_at_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* CustomerIndex::_internal_mutable_expires_at() {
  
  if (expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    expires_at_ = p;
  }
  return expires_at_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* CustomerIndex::mutable_expires_at() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.CustomerIndex.expires_at)
  return _internal_mutable_expires_at();
}
inline void CustomerIndex::set_allocated_expires_at(PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at_);
  }
  if (expires_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at)->GetArena();
    if (message_arena != submessage_arena) {
      expires_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expires_at, submessage_arena);
    }
    
  } else {
    
  }
  expires_at_ = expires_at;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.CustomerIndex.expires_at)
}

// -------------------------------------------------------------------

// AppConnectionProps

// string connection_id = 1;
inline void AppConnectionProps::clear_connection_id() {
  connection_id_.ClearToEmpty();
}
inline const std::string& AppConnectionProps::connection_id() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.AppConnectionProps.connection_id)
  return _internal_connection_id();
}
inline void AppConnectionProps::set_connection_id(const std::string& value) {
  _internal_set_connection_id(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.AppConnectionProps.connection_id)
}
inline std::string* AppConnectionProps::mutable_connection_id() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.AppConnectionProps.connection_id)
  return _internal_mutable_connection_id();
}
inline const std::string& AppConnectionProps::_internal_connection_id() const {
  return connection_id_.Get();
}
inline void AppConnectionProps::_internal_set_connection_id(const std::string& value) {
  
  connection_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AppConnectionProps::set_connection_id(std::string&& value) {
  
  connection_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.AppConnectionProps.connection_id)
}
inline void AppConnectionProps::set_connection_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  connection_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.AppConnectionProps.connection_id)
}
inline void AppConnectionProps::set_connection_id(const char* value,
    size_t size) {
  
  connection_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.AppConnectionProps.connection_id)
}
inline std::string* AppConnectionProps::_internal_mutable_connection_id() {
  
  return connection_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AppConnectionProps::release_connection_id() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.AppConnectionProps.connection_id)
  return connection_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AppConnectionProps::set_allocated_connection_id(std::string* connection_id) {
  if (connection_id != nullptr) {
    
  } else {
    
  }
  connection_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), connection_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.AppConnectionProps.connection_id)
}

// .google.protobuf.Timestamp connection_time = 2;
inline bool AppConnectionProps::_internal_has_connection_time() const {
  return this != internal_default_instance() && connection_time_ != nullptr;
}
inline bool AppConnectionProps::has_connection_time() const {
  return _internal_has_connection_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& AppConnectionProps::_internal_connection_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = connection_time_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& AppConnectionProps::connection_time() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.AppConnectionProps.connection_time)
  return _internal_connection_time();
}
inline void AppConnectionProps::unsafe_arena_set_allocated_connection_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* connection_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_time_);
  }
  connection_time_ = connection_time;
  if (connection_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.AppConnectionProps.connection_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AppConnectionProps::release_connection_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = connection_time_;
  connection_time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AppConnectionProps::unsafe_arena_release_connection_time() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.AppConnectionProps.connection_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = connection_time_;
  connection_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AppConnectionProps::_internal_mutable_connection_time() {
  
  if (connection_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    connection_time_ = p;
  }
  return connection_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* AppConnectionProps::mutable_connection_time() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.AppConnectionProps.connection_time)
  return _internal_mutable_connection_time();
}
inline void AppConnectionProps::set_allocated_connection_time(PROTOBUF_NAMESPACE_ID::Timestamp* connection_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_time_);
  }
  if (connection_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_time)->GetArena();
    if (message_arena != submessage_arena) {
      connection_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_time, submessage_arena);
    }
    
  } else {
    
  }
  connection_time_ = connection_time;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.AppConnectionProps.connection_time)
}

// .google.protobuf.StringValue ip_address = 3;
inline bool AppConnectionProps::_internal_has_ip_address() const {
  return this != internal_default_instance() && ip_address_ != nullptr;
}
inline bool AppConnectionProps::has_ip_address() const {
  return _internal_has_ip_address();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& AppConnectionProps::_internal_ip_address() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = ip_address_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& AppConnectionProps::ip_address() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.AppConnectionProps.ip_address)
  return _internal_ip_address();
}
inline void AppConnectionProps::unsafe_arena_set_allocated_ip_address(
    PROTOBUF_NAMESPACE_ID::StringValue* ip_address) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_address_);
  }
  ip_address_ = ip_address;
  if (ip_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.AppConnectionProps.ip_address)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* AppConnectionProps::release_ip_address() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = ip_address_;
  ip_address_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* AppConnectionProps::unsafe_arena_release_ip_address() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.AppConnectionProps.ip_address)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = ip_address_;
  ip_address_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* AppConnectionProps::_internal_mutable_ip_address() {
  
  if (ip_address_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    ip_address_ = p;
  }
  return ip_address_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* AppConnectionProps::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.AppConnectionProps.ip_address)
  return _internal_mutable_ip_address();
}
inline void AppConnectionProps::set_allocated_ip_address(PROTOBUF_NAMESPACE_ID::StringValue* ip_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_address_);
  }
  if (ip_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_address)->GetArena();
    if (message_arena != submessage_arena) {
      ip_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip_address, submessage_arena);
    }
    
  } else {
    
  }
  ip_address_ = ip_address;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.AppConnectionProps.ip_address)
}

// bool simplex_mode = 4;
inline void AppConnectionProps::clear_simplex_mode() {
  simplex_mode_ = false;
}
inline bool AppConnectionProps::_internal_simplex_mode() const {
  return simplex_mode_;
}
inline bool AppConnectionProps::simplex_mode() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.AppConnectionProps.simplex_mode)
  return _internal_simplex_mode();
}
inline void AppConnectionProps::_internal_set_simplex_mode(bool value) {
  
  simplex_mode_ = value;
}
inline void AppConnectionProps::set_simplex_mode(bool value) {
  _internal_set_simplex_mode(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.AppConnectionProps.simplex_mode)
}

// -------------------------------------------------------------------

// CustomerNumber

// .com.elarian.hera.proto.CustomerNumberProvider provider = 1;
inline void CustomerNumber::clear_provider() {
  provider_ = 0;
}
inline ::com::elarian::hera::proto::CustomerNumberProvider CustomerNumber::_internal_provider() const {
  return static_cast< ::com::elarian::hera::proto::CustomerNumberProvider >(provider_);
}
inline ::com::elarian::hera::proto::CustomerNumberProvider CustomerNumber::provider() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.CustomerNumber.provider)
  return _internal_provider();
}
inline void CustomerNumber::_internal_set_provider(::com::elarian::hera::proto::CustomerNumberProvider value) {
  
  provider_ = value;
}
inline void CustomerNumber::set_provider(::com::elarian::hera::proto::CustomerNumberProvider value) {
  _internal_set_provider(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.CustomerNumber.provider)
}

// string number = 2;
inline void CustomerNumber::clear_number() {
  number_.ClearToEmpty();
}
inline const std::string& CustomerNumber::number() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.CustomerNumber.number)
  return _internal_number();
}
inline void CustomerNumber::set_number(const std::string& value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:com.elarian.hera.proto.CustomerNumber.number)
}
inline std::string* CustomerNumber::mutable_number() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.CustomerNumber.number)
  return _internal_mutable_number();
}
inline const std::string& CustomerNumber::_internal_number() const {
  return number_.Get();
}
inline void CustomerNumber::_internal_set_number(const std::string& value) {
  
  number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CustomerNumber::set_number(std::string&& value) {
  
  number_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.elarian.hera.proto.CustomerNumber.number)
}
inline void CustomerNumber::set_number(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.elarian.hera.proto.CustomerNumber.number)
}
inline void CustomerNumber::set_number(const char* value,
    size_t size) {
  
  number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.elarian.hera.proto.CustomerNumber.number)
}
inline std::string* CustomerNumber::_internal_mutable_number() {
  
  return number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CustomerNumber::release_number() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.CustomerNumber.number)
  return number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomerNumber::set_allocated_number(std::string* number) {
  if (number != nullptr) {
    
  } else {
    
  }
  number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), number,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.CustomerNumber.number)
}

// .google.protobuf.StringValue partition = 3;
inline bool CustomerNumber::_internal_has_partition() const {
  return this != internal_default_instance() && partition_ != nullptr;
}
inline bool CustomerNumber::has_partition() const {
  return _internal_has_partition();
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& CustomerNumber::_internal_partition() const {
  const PROTOBUF_NAMESPACE_ID::StringValue* p = partition_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::StringValue&>(
      PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::StringValue& CustomerNumber::partition() const {
  // @@protoc_insertion_point(field_get:com.elarian.hera.proto.CustomerNumber.partition)
  return _internal_partition();
}
inline void CustomerNumber::unsafe_arena_set_allocated_partition(
    PROTOBUF_NAMESPACE_ID::StringValue* partition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partition_);
  }
  partition_ = partition;
  if (partition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.elarian.hera.proto.CustomerNumber.partition)
}
inline PROTOBUF_NAMESPACE_ID::StringValue* CustomerNumber::release_partition() {
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = partition_;
  partition_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* CustomerNumber::unsafe_arena_release_partition() {
  // @@protoc_insertion_point(field_release:com.elarian.hera.proto.CustomerNumber.partition)
  
  PROTOBUF_NAMESPACE_ID::StringValue* temp = partition_;
  partition_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* CustomerNumber::_internal_mutable_partition() {
  
  if (partition_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::StringValue>(GetArena());
    partition_ = p;
  }
  return partition_;
}
inline PROTOBUF_NAMESPACE_ID::StringValue* CustomerNumber::mutable_partition() {
  // @@protoc_insertion_point(field_mutable:com.elarian.hera.proto.CustomerNumber.partition)
  return _internal_mutable_partition();
}
inline void CustomerNumber::set_allocated_partition(PROTOBUF_NAMESPACE_ID::StringValue* partition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(partition_);
  }
  if (partition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partition)->GetArena();
    if (message_arena != submessage_arena) {
      partition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition, submessage_arena);
    }
    
  } else {
    
  }
  partition_ = partition;
  // @@protoc_insertion_point(field_set_allocated:com.elarian.hera.proto.CustomerNumber.partition)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace hera
}  // namespace elarian
}  // namespace com

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::com::elarian::hera::proto::CustomerNumberProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::elarian::hera::proto::CustomerNumberProvider>() {
  return ::com::elarian::hera::proto::CustomerNumberProvider_descriptor();
}
template <> struct is_proto_enum< ::com::elarian::hera::proto::ChannelNumberProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::elarian::hera::proto::ChannelNumberProvider>() {
  return ::com::elarian::hera::proto::ChannelNumberProvider_descriptor();
}
template <> struct is_proto_enum< ::com::elarian::hera::proto::MediaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::elarian::hera::proto::MediaType>() {
  return ::com::elarian::hera::proto::MediaType_descriptor();
}
template <> struct is_proto_enum< ::com::elarian::hera::proto::CustomerEventDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::elarian::hera::proto::CustomerEventDirection>() {
  return ::com::elarian::hera::proto::CustomerEventDirection_descriptor();
}
template <> struct is_proto_enum< ::com::elarian::hera::proto::CustomerRequestOrigin> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::elarian::hera::proto::CustomerRequestOrigin>() {
  return ::com::elarian::hera::proto::CustomerRequestOrigin_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_5fmodel_2eproto
